

## 코딩을 지탱하는 기술

니시오 히로카즈

<br>

### 시작하며

- '변화하고 있는 지식'을 꾸준히 습득하지 않으면, 이미 학습한 지식도 점점 가치를 잃게 된다.
- 학습에는 3가지 중요한 포인트가 있다.
  1. 비교를 통한 학습
     다수의 언어를 비교하는 것이다. 
     무엇이 그 언어만이 가진 특유의 개념이고, 
     무엇이 언어 간에 공통으로 사용되는 개념인지를 배울 수 있다.
  2. 역사를 통한 학습
     언어의 발달 과정을 따라가는 것이다. 
     어떻게 탄생했고, 어떤 식으로 변화해 왔는지를 배움으로 
     '왜 이런 식으로 동작하고 있는지'에 대한 의문을 풀 수 있다.
  3. 만드는 것을 통한 학습
     직접 언어를 만드는 것이다. 
     '나라면 어떻게 만들까?'를 생각함으로, 
     언어 설계자의 의도를 쉽게 이해할 수 있게 된다. 
     또한 실제로 만들어봄으로써 자신이 잘 이해하지 못한 것을 알 수 있게 된다.
- 이 책의 목적은 '왜'를 해결하는 것이다.

<br>

### 역자의 글

- 개발자의 고통 중 하나는 새로운 프로그래밍 언어나 개발 환경이 출시될 때마다, 다시 새롭게 공부를 해야 한다는 것이다. 물론 공통적으로 사용되는 개념을 잘 이해하고 있다면, 새로운 프로그래밍 언어를 금방 사용할 수 있는 것도 사실이다.
- 아마 기존에 나와 있는 개발 언어 책 중에서 '클래스'에 관해 가장 알기 쉽고 명쾌하게 해설하고 있는 책이 아닌가 싶다.

------

<br>

### 1장

## 효율적으로 언어 배우기

- 개운치 않은 기분은 새롭게 배운 지식이 자신의 경험이나 본래 본인이 가지고 있던 지식과 연계되지 않을 때 생기게 된다.

<br>

### 1) 비교를 통한 배움

- 많은 언어에서 공통적으로 사용되는 개념이야말로 중요한 지식이다.
- 그 지식을 습득하게 되면 또 다른 언어를 배우는 것도 매우 수월할 것이다.

<br>

#### 규칙은 언어마다 다르다

- 복수의 언어를 비교해서 학습할 때 알게 되는 것이 있다. 그것은 '규칙은 언어마다 다르다'는 것이다.

<br>

#### C언어와 Ruby의 참거짓 값

- C언어를 배운 사람은 **'0이 거짓이고**, 그 이외의 값은 참이다'라고 알고 있을 것이다.
- C언어만 배웠다면 **'프로그래밍 언어에서는 일반적으로 0이 거짓이고**, 그 이외의 값은 참이다'라고 일반화하기 쉽다.
- 하지만 Ruby를 공부해보면 'Ruby에서는 0이 참이다'라는 것을 알고 놀랄 것이다.

```c
#include <stdio.h>

int main() {
  if (0) {
    printf("true!\n");
  } else {
    printf("false!\n");
  }
}	// false!
```

```ruby
if 0 then
  print "true!"
else
  print "false!"
end 	// true!
```

- 이 놀라운 사실은 잘못된 고정관념을 고칠 수 있는 기회를 준다.

<br>

#### Java의 참거짓 값

- Java에서는 참거짓 값을 위한 형을 가지고 있어서 조건식에서도 그 형을 사용하지 않으면 안 된다.
- 0은 단순히 정수형을 의미하기 때문에 조건식에 0을 사용하게 되면 컴파일 에러가 발생한다.
- 즉, 세상에는 0이 참인 언어, 0이 거짓인 언어, 0이 참도 거짓도 아닌 언어가 존재하고 있는 것이다.

<br>

### 2) 역사를 통한 배움

#### 언어 설계자의 의도를 이해하자

- 프로그래밍 언어가 가진 어떤 기능이 '어떤 의미인지' 설명을 읽고도 뭔가 개운치 않은 느낌을 받은 적이 있을 것이다. 그때 알고 싶은 그 기능이 '왜 필요한지'에 대한 대답일 것이다.
- 언어 설계자는 어떤 문제를 해결하기 위해 그 언어를 만든 것일까?
- 언어가 어떤 흐름을 따라 만들어졌는지 알게 되면 그 기능이 왜 필요한지 납득할 수 있게 된다.

<br>

#### 어떤 언어를 배워야 하는지는 아무도 모른다

- '프로그래밍을 배우고 싶은데 어떤 언어를 배우면 좋을까?'라는 질문은 무의미하다.

<br>

#### 언어에 의존하지 않는 보편적인 지식의 습득

- 개별 언어 지식이 5년 후, 10년 후에도 도움이 될지는 아무도 모른다.
- 몇 가지 언어를 비교하거나 언어의 역사나 이유를 조사함으로, 언어가 바뀌어도 통용할 수 있는 이해력을 기를 필요가 있다.

<br>

### 3) 정리

- '비교를 통한 배움'이란 특정 언어로 프로그래밍을 배우는 것이 아니라, 다수의 언어를 비교해 가면서 학습하는 것을 의미한다. 이를 통해, 무엇이 언어에 따라 다르고 무엇이 공통적인지 배울 수 있다.
- '역사를 통한 배움'이란 언어가 어떻게 바뀌었고 바뀌기 전에는 어떤 의문점이 존재했는지 학습하는 것을 의미한다. 이를 통해, 언어가 가지고 있는 다양한 기능이 '왜' 탄생했는지 배울 수 있다.

<br>

### 2장

## 프로그래밍 언어를 조감하다

- 프로그래밍 언어는 왜 탄생한 것일까?
- 무엇을 위해 프로그래밍 언어를 발명한 것일까?

<br>

### 1) 프로그래밍 언어 탄생의 역사

- 오래된 것과 새로운 것을 비교할 때 깊이 있는 이해가 가능하다.
- 많은 것이 과거의 것을 발전시켜 만들어졌다. 즉, 새로운 것은 과거의 것을 알고 난 후에야 만들어지는 것이다. 그러므로 옛날 사람 시점에서 생각하는 방법은 새로운 것을 배우는 사람에겐 매우 유리하게 작용한다.
- 프로그래밍 언어는 인간을 편하게 하기 위해 만들어졌다.

<br>

#### 케이블을 연결하다

- 1946년에 ENIAC (Electronic Numerical Integrator and Computer)이 발명됐다. 이 컴퓨터는 '무엇을 계산할지', 즉 목적에 따라 프로그램을 변경할 수 있었다. 지금으로 말하면 '프로그래밍'이 가능한 컴퓨터였다. 그러나 그 방법은 지금의 프로그래밍과는 매우 달랐다. 이 컴퓨터의 수많은 단자에 케이블을 여기저기 연결하는 것이 프로그래밍이었다.

<br>

#### 프로그램 내장 방식으로

- 1949년 EDSAC (Electronic Delay Storage Automatic Calculator)이 개발됐다. 이것은 테이프에 구멍을 뚫어서 데이터를 표현하고, 컴퓨터가 이를 읽어 들이도록 한 구조다. 프로그램 자체도 데이터로서 입력된다. 물리적 케이블을 교환하는 대신, 종이 테이프의 데이터를 읽어 들여서 프로그램을 변경할 수 있었다. 작업이 수월해졌다고는 하지만, 사람이 프로그램을 읽거나 쓰는 것은 여전히 어려웠다. 어디까지나 기계가 읽기 위한 언어, 즉 '기계어'였던 것이다. 입력에 사용하는 종이 테이프는 하나의 열에 데이터를 표현하기 위한 5개의 구멍과 종이를 이동시키기 위한 한 개의 구멍으로 구성되어 있었다. 오직 5개의 구멍만으로 프로그램을 표현해야 했다.

<br>

#### FORTRAN의 등장

- 1954년, 드디어 지금 사용하고 있는 것과 비슷한 프로그래밍 언어가 고안되었다. 바로 FORTRAN이다. FORTRAN이란 이름은 Formula Translating System(수식 변환 시스템)을 의미한다.지금은 프로그래밍 언어로 'x 곱하기 y 더하기 z'를 x * y + z라고 표현할 수 있는 것을 너무나 당연히 여기지만, 그것을 최초로 표현한 것이 FORTRAN이다. 명칭이 의미하듯 '수식을 기계어로 변환하는 것'이 FORTRAN의 특징 중 하나였다. 이 때는 효율이 높은 프로그램을 위해서는 사람이 기계어를 쓰는 수밖에 없다고 생각했다. 실제로 초기 FORTRAN 컴파일러가 출력하는 기계어는 능숙한 프로그래머가 짠 기계어에 비교하면 효율이 매우 떨어졌다. 그러나 코드량이 눈에 띄게 줄었고, 코드를 읽기 쉬워짐에 따라 많은 사용자층을 얻을 수 있었다.
- FORTRAN 설계자인 John Backus는 다음과 같이 말했다. '내가 이룬 성과의 대부분은 나태함에서 오고 있다. 나는 프로그램 짜는 것을 좋아하지 않았다. 그래서 프로그램을 쉽게 짤 수 있는 시스템을 만들었다.'

<br>

### 2) 프로그래밍 언어 탄생의 목적

- 프로그램은 어떤 것을 편하게 하기 위해 고안된 것이다. 편하게 하는 것은 부실하게 하는 것과는 다르다. 부실하게 만들어서 나중에 고생케 하는 것은 편하게 만들었다고 볼 수 없다.

<br>

#### 나태 - 프로그래머의 3대 미덕

- 프로그래밍 언어 Perl의 설계자인 Larry Wall은 저서 \<\<Programming Perl>>에서 프로그래머가 가져야 할 3가지 자질로서 '나태, 조바심, 자만심'을 제안했다. 이것이 프로그래머의 3대 미덕이라고 불린다.

  - 나태 (Laziness)
    전체 에너지 소비를 줄이기 위해 대부분의 능력을 집중하는 기질.
    이렇게 노동력을 줄이기 위해 만든 프로그램은 다른 사람들도 사용하게 되며,
    그 프로그램에 관한 질문에 일일이 답하는 수고를 덜기 위해 문서를 만들게 된다.
    이는 프로그래머에게 있어 가장 중요한 자질이기도 하며,
    이 책이 존재하는 이유이기도 하다.
    조바심과 자만심에 관해서도 참조할 것.

    \- \<\<Programming Perl 3rd edition>>

- 당장에 눈에 보이는 편리함을 요구하는 것이 아니라, 앞날까지 생각해서 가장 편한 방법을 선택하는 것이다. 즉, 같은 성과를 달성하는 다수의 방법 중 가장 생산성이 높은 것을 선택함을 의미한다.

- 이 책에 따르면 Perl이라는 이름은 'Practical extraction and report language'(실용적 데이터 취득 및 리포트 작성 언어)라는 의미다. Perl은 리포트 작성을 수월하게 하기 위해 만들어진 언어다.

<br>

#### 언어에 따라 다른 '편리함'의 의미

- 프로그래밍 언어의 목적은 '편리함'이라고 말했지만, 세상에는 왜 수많은 언어가 존재하는 것일까?

<br>

#### 무엇을 편하게 하고 싶은 것인가?

- 예를 들어 C++은 빠른 실행 속도를 중시하고 있는 언어다. C로 만든 코드보다 빠른 속도가 날 수 있도록 고안했지만, 결과적으로 언어 사양이 더 복잡해지고 말았다.
- 반면에, Scheme은 언어 사양을 쉽게 파악할 수 있는 데 중점을 두고 있는 언어다. 언어 사양이 최소한이 되도록 했고, 사양서 전체가 50페이지 밖에 되지 않는다. 그러나 구문이 수많은 괄호로 이루어져있어 싫어하는 사람도 많다.

<br>

#### 어떤 프로그램을 편하게 만들고 싶은가?

- Python은 다른 사람이 쓴 코드를 쉽게 해석할 수 있는 데 중점을 두고 있다. Scheme보다 C에 가깝고 프로그래머에게 익숙한 많은 제어 구문을 채용하고 있으며, 인텐드(Intend, 들여쓰기)를 강조하고 있다. 그에 반해 속도가 느리며, 사양도 단순하지 않다.
- PHP는 웹 서비스를 쉽게 만들 수 있도록 해준다. 그러나 문장 처리를 편하게 하지는 못한다.
- 올바른 설계는 사용하는 사람이 무엇을 목적으로 하고 있는지에 따라 달라진다.
- 다양한 설계 언어가 있는 것은 사람에 따라 다양한 목적이 있기 때문이다.
- 빠른 속도를 위해 만들어진 C++과 쉬운 코드 해석을 위해 설계된 Python을 비교해서 C++이 읽기 어렵다느니 Python이 느리다느니 하는 것은 유익하지 못한 논쟁이다.

<br>

### 3) 정리

- 프로그래밍 언어는 사람을 편하게 하기 위해 만들어졌다. 그러나 무엇이 편한지는 언어에 따라 다르다.
- 언어는 도구다. 어떤 언어가 자신의 목적에 적합한지는 그 언어를 사용할 때 자신이 어느 정도의 생산성을 발휘할 수 있는지로 판단할 수 있다.
- 자신이 어느 정도 성과를 낼 수 있는지를 고려해서 결정해야 한다.
- 좋은 도구를 현명하게 선택하여 적재적소에 사용하도록 하자.

<br>

### 3장

## 문법의 탄생

- 프로그래밍 언어에는 수많은 규칙이 있다. 무엇 때문에 많은 규칙이 존재하는 걸까?

<br>

### 1) 문법이란?

- 프로그래밍 언어에는 여러 가지 규칙이 있다.
- 문법이란, 프로그래밍 언어 설계자가 만든 '이렇게 쓰면 이런 의미로 해석된다'라고 정한 규칙이다.
- 문법이란 무엇을 편하게 하기 위해 만들어졌을까?
- FORTH라는 언어는 문법이 거의 없다.
- LISP라는 언어는 괄호로 코드 구조를 표현한다.
- FORTH와 LISP가 가지고 있는 기능은 현재의 프로그래밍 언어에서도 중요한 역할을 하고 있다.
- '문법과 구문의 차이점은 무엇일까?'라는 의문을 가질 수도 있다. 둘 다 프로그램을 만들기 위한 규칙이란 점은 같다. 단지 구문 쪽이 좀 더 좁은 범위를 가리키는 경우가 많다. 예를 들어 if 문을 구문이라고 부르는 것은 자연스럽지만, 연산자 우선순위를 구문이라고 부르는 것은 부자연스럽다.

<br>

#### 연산자 우선순위

- 연산자란 덧셈에 사용하는 +나 곱셈에 사용하는 *을 의미한다.

#### 문법은 언어 설계자가 정한 규칙

- 언어 설계자가 정한 규칙이 바로 문법이다.
- 문법은 언어에 따라 다르다.
- 연산자의 종류는 언어에 따라 다르다.
- 예를 들어 C언어에서는 '='가 연산자이며, 일반적인 가감승제와는 틀리게 '우결합성 연산자'이다. 그래서 소스 코드에 x=y=1이라고 써 있다면, 이것은 x=(y=1)이라고 해석된다.

<br>

### 2) 스택 머신과 FORTH

- FORTH는 1958년 경에 개발되어 문법이 거의 존재하지 않는 언어다.
- 설계자 Charles H. Moore에 따르면 'FORTH는 가장 간단한 컴퓨터 언어'이다. '세상의 모든 언어가 가독성이 있다고 주장하고 있지만, 처음 그 언어를 다루는 사람은 항상 당황한다. 이는 난해하고 변덕스러운 문법 때문이다. FORTH는 구문을 최대한 제한함으로 문제를 해결한다'는 것이 그의 주장이다.

<br>

#### 계산 순서

- FORTH에서는 '1과 2를 더한다'는 코드를 다음과 같이 쓴다.

```FORTH
1 2 +
```

- FORTH의 가장 큰 특징인 '스택(stack)', 즉 '값을 쌓아 두는 장소'를 사용한다.

<br>

#### 연산 순서를 어떻게 표현할까?

- '1과 2를 더한 것에 3을 곱하다'는 다음과 같이 표현할 수 있다.

```FORTH
1 2 + 3 *
```

<br>

- '2와 3을 곱한 후 1을 더한다'는 다음과 같이 표현할 수 있다.

```FORTH
2 3 * 1 +
```

- 거의 한국어 어순 그대로다.
- 만약 1, 2, 3의 순서가 중요하다면 다음과 같이 쓸 수도 있다.

```FORTH
1 2 3 * +
```

- '1과 (2와 3을 곱한 것을) 더한다'이다.
- 한국어로는 순서상 오류를 피하기 위해 어디까지가 한 구역인지 괄호를 사용했지만, FORTH에서는 괄호도 '우선순위라는 규칙'도 도입하지 않고 표현하고 있다.

<br>

### 3) 구문 트리와 LISP

- '하나의 구역을 표현하기 위해 항상 괄호를 사용하자'는 선택을 한 언어가 있다. 1958년에 탄생한 LISP이다.

<br>

#### 계산의 흐름

- LISP로 '1과 2를 더한다'는 코드는 다음과 같이 표현한다.

```LISP
(+ 1 2)
```

- 먼저 괄호로 시작해서 '더해'라는 명령이 앞에 나온다. 그 다음 공란으로 간격을 만들고 '무엇을 더할 것인지'를 쓴다. 

<br>

#### 계산 순서를 어떻게 표현할까?

- '1과 2를 더한 후 3을 곱한다'

```lisp
(* (+ 1 2) 3)
```

<br>

- FORTH에서도 LISP에서도 구문 트리는 동일하다.
- 실은 단순한 문법으로 이루어진 이 두 개의 언어는 특정 규칙을 사용해 구문 트리를 모방한 것뿐이다. 즉, 이 2가지 언어의 생김새는 크게 다르지만 동일한 구조를 사용해서 '하고자 하는 것'을 표현하고 있다.

<br>

#### 현재도 살아있는 구문 트리

- 구문 트리가 사용되고 있는 것은 최신 언어도 마찬가지다.
- Python에 기본으로 장착되어 있는 ast 라이브러리를 사용하면 특정 코드가 어떤 구문 트리로 구성되어 있는지 알 수 있다.
- ast는 abstract syntax tree의 약자다. 정확하게는 '추상 구문 트리'다. 복잡한 구문을 가지고 있는 언어에서는 '구문 트리' 자체가 수많은 구문으로 이루어져 이해하기 어렵다. 그래서 그것을 간단히 한 것이 추상 구문 트리다.

```python
>>> import ast
>>> ast.dump(ast.parse("1 + 2"))
Module(
  body=[Expr(
    value=BinOp(
      left=Num(n=1),
      op=Add(),
      right=Num(n=2))
  	)
  ]
)

>>> ast.dump(ast.parse("(1 + 2) * 3"))
Module(
  body=[Expr(
    value=BinOp(
      left=BinOp(
        left=Num(n=1),
        op=Add(),
        right=Num(n=2)
      ),
      op=Mult(),
      right=Num(n=3))
    )    
  ]
)
```

- **Binop op=Add()**는 '덧셈'을 의미하고, LISP의 '+'에 대응된다.
- **Num n=1**은 '수치 1'로, 이것은 LISP의 '1'에 대응된다.
- LISP는 문법이 간단해서 코드와 구문이 알기 쉽게 연결된다. 또한 '매크로'라는 구문 트리를 바꿔주는 메커니즘을 가지고 있어서, 구조체 프로그래밍과 같은 프로그래밍 언어의 발전에 큰 기여를 하게 된다.

<br>

### 4) 중위 표기법

- LISP에서는 '1 더하기 2'를 (+ 1 2)라고 표현한다. 연산자는 연산 대상의 앞에 배치된다.
- FORTH에서는 '1 더하기 2'를 1 2 +라고 표현한다. 연산자는 연산 대상의 뒤에 배치된다.
- 수식에서는 '1 더하기 2'를 1 + 2로 표현한다. 연산자는 연산 대상의 사이에 배치된다.
- 이와 같이 연산자를 연산 대상 뒤에 두는 것을 후위 표기법, 앞에 두는 것을 전위 표기법, 사이에 두는 것을 중위 표기법이라고 한다.
- 이 3가지 방법은 식을 표현하기 위한 약속에 불과하다. 하지만 프로그래밍 언어가 탄생하기 이전부터 사람들은 중위 표기법에 익숙했다.
- FORTRAN은 이 익숙한 방법을 적용할 수 있도록 만들어졌다. FORTRAN이란 이름이 Formula Translating System(수식 번역 시스템)의 약어인 이유도 이 때문이다.
- FORTRAN은 연산자 우선순위나 결합성 등 다양한 규칙을 도입해 문법을 만들었다. 그 결과, 프로그래머는 익숙한 방법으로 수식을 사용할 수 있게 되었다.

<br>

#### 구문 해석기

- 구문 해석기(파서, Parser)는 소스 코드를 문자열로 읽어 들여 해석하고, 그것을 구문 트리로 만드는 프로그램이다.
- FORTRAN에서 프로그램이 컴파일 될 때도 이 구문 해석기가 소스 코드를 문자열로 읽어 들여 구문 트리로 변환하는 작업을 하고 있다.
- 문법 설계와 구문 분석기 구현은 프로그래밍 언어의 외관을 결정하는 중요한 요소다.
- 언어 설계자는 문법을 설계할 때 무엇을 쉽게 쓸 수 있도록 할 것인지, 어떤 실수를 줄이도록 할 것인지 등 프로그래밍 언어가 사용자에게 어떤 가치를 줄 수 있을지 생각한다.

<br>

#### 규칙간 마찰

- 예를 들어 C++에서는 템플릿 기능을 추가할 대 vector\<int>와 같이 '부등호로 감싸는 표기'를 도입했다. 그러나 이 부등식 괄호를 이중으로 하면 괄호를 닫는 >>가 기존의 '쉬프트(shift) 연산자'로 해석되어버린다. 이 문제를 구문 분석기에서 해결하는 것이 쉽지 않아서 프로그래머가 공백 문자를 사이에 입력해서 >>가 되지 않도록 하는, 즉 운영 측면에서 문제를 해결하도록 했다.

```c++
// OK
vector<vector<int> > x;

// NG
vector<vector<int>> y;
```

- 물론 구문 분석기가 양쪽 구문을 문제없이 해석하도록 개선하는 것이 이상적이다. 그러나 현실은 이상과 다르다. 이것은 C++에 제한된 얘기가 아니다. 다른 언어에도 과거 규칙과의 마찰로 인해 부자연스러운 규칙이 생겨난 경우가 있다.

<br>

### 5) 정리

- 언어에 따라 표현 방법이 다르다. 그러나 구문 트리로 표현하면 거의 동일하다.
- 이들 언어에 차이가 생긴 것은 '어떤 문자열을 쓰면 어떤 구문 트리가 생기는가'라는 규칙이다. 이것이 문법이다.
- FORTH나 LISP는 규칙이 적은 것을 중시했다. 그러나 시장이 요구한 것은 규칙이 적거나 간단한 것이 아니었다.
- FORTRAN은 '*가 +보다 우선순위가 높다' 등의 정해진 규칙을 대량으로 도입해서 '다가가기 쉬운 작성법'을 중시했다. 그리고 그런 설계 방침의 성공으로, FORTRAN 방식이 LISP나 FORTH보다 많은 사람에게 사랑 받게 되었다.
- 현재 대부분의 프로그래밍 언어는 FORTRAN 식의 '다가가기 쉬운 작성법'을 목표로 하고 있다. 하지만 모순 없이 해석할 수 있는 문법을 만들어내는 것은 어려운 작업이다. 특히 나중에 새로운 문법을 추가할 때 기존 문법과 마찰되지 않도록 하는 것은 더욱 그렇다. 이 때문에 현실의 프로그래밍 언어에는 이해하기 어려운 작성법이 여전히 존재하는 것이다.

<br>

### 4장

## 처리 흐름 제어

- 프로그래밍 언어에는 if문, while문, for문 등 처리 흐름을 제어하기 위한 제어 구문이 존재한다.
- 왜 이런 제어 구문이 있는 것일까?

<br>

### 1) 구조화 프로그래밍의 탄생

- 1960년대 후반, '사람이 프로그램을 보다 편하게 쓰고 읽을 수 있도록 규칙을 만들자'는 흐름을 타고 '구조화 프로그래밍'이 태어났다. 자주 사용하고 있는 if문이나 while문 등의 규칙(구문)을 도입하여 코드 구조를 쉽게 만들자는 생각이었다.

<br>

### 2) if가 탄생하기 전

- if문 없이 어떻게 프로그램을 짜면 좋을까?

<br>

#### if는 왜 있는 걸까?

- 어셈블리어에는 if문이 없다. 그러나 어셈블리어는 C언어에서 간단히 변환(컴파일)된다. 그래서 if문을 사용한 코드를 C언어로 쓰고, 그것을 어셈블리어로 컴파일하도록 한다.
- C언어 소스는 다음과 같다. 'x가 456과 같으면 처리를 한다'는 코드다.

```c
int main() {
  int x = 123;
	  /* if문 앞 */
  if (x == 456) {
      /* if문 안 */
  }
      /* if문 뒤 */
}
```

- 컴파일하면 다음과 같은 어셈블리어 코드가 출력된다.

```assembly
_main:
		......
		mov1	$123, -8(%rbp)	#1
		# if문 앞
		mov1	-8(%rbp), %eax	#2
		cmp1	$456, %eax
		jne 	LBB1_2			#3
		# if문 안				   #4
LBB1_2:							#5
		#if문 뒤
		......
```

- -8(%rbp)는 원래 코드의 x라고 해석한다.
- \#1에서 x에 수치 123을 대입하고 있다.
- \#2에서 x의 값을 %eax라는 임시 저장소에 이동 후 수치 456과 비교한다.
- \#3이 중요한 부분으로, '바로 직전 비교에서 양쪽이 동일하지 않으면 LBB1_2로 점프'하라는 명령이다. 역으로 말하면, '양쪽이 동일하면 점프하지 않고 다음 명령을 실행한다'는 것이다.
- \#4가 if문 안쪽 코드로 양쪽이 동일할 때만 실행된다. 동일하지 않으면 LBB1_2(\#5)로 점프하기 때문에 \#4는 실행되지 않는다.
- 이와 같이 '조건을 만족하면 점프'라는 명령은 꽤 초기부터 존재했다.

<br>

#### If-else 사용의 장점

- '조건이 참인 경우와 거짓인 경우의 처리 흐름을 분배한다'는 패턴은 프로그래밍에 빈번히 사용된다. 이것을 간단하고 읽기 쉬운 형태로 쓰기 위해 if-else 구문이 새롭게 도입된 것이다.
- 프로그래밍을 하면서 else가 반드시 필요한 건 아니다. 하지만 사용했으면 좋겠다. 그게 더 편하게 읽을 수 있기 때문이다.

<br>

### 3) while, 반복되는 if를 읽기 쉽게 표현

- ​

















------

### 칼럼

#### 이해력을 확인하기 위해서는 결과물(output)을 확인한다

- 어떤 것을 공부해서 '이해했다'고 치자. 그것은 '정말 이해했다'일까 아니면 '이해했다라고 착각했다'일까?
- 이해한 것이 맞는지를 확인하기 위해서는 결과물(output)이 필요하다. 
- 자신이 이해한 것을 정리해서 그것을 제3자에게 검증을 받는 수밖에 없다.
- 프로그래머는 이런 점에서는 혜택을 받고 있다. 프로그래밍 언어의 결과물은 언어 처리계가 틀린 곳을 자세히 지적해준다.
- 그것을 이해하려 하지 않고서는 언어 처리계와 제대로 된 커뮤니케이션을 할 수가 없다.

<br>

#### 무엇을 배우면 좋을지 모르는 이유

- '무엇을 배우면 좋습니까?' 이는 자주 듣는 질문이다. 이 질문에 대답하기 전에 한 가지를 물어보고 싶다. '무엇을 만들고 싶은가요?' 목적이 명확하지 않으면 최선의 방법 또한 가르쳐줄 수 없다.
- '어쨌든 전부 다 한 번은 공부해보자'는 전략은 어리석다.
- '무엇을 배울지, 무엇을 배우면 좋을지'를 정할 때 필연적으로 지표가 될 수 있는 것이 '무엇을 만들고 싶은가?', 즉 목적을 명확히 하는 것이다. 
- 목적을 달성하기 위해 필요한 것부터 배우면 된다.
- '무엇을 만들까?'를 결정할 수 없다면, 처음부터 완벽한 것을 만들려고 생각하고 있는 것은 아닌지 고민해보자.
- 처음부터 굉장한 것을 만들려고 생각해서 오히려 손도 대지 못하고 있다면, 시간이 흘러도 굉장한 것을 만들 수 없다. 우선은 간단한 것도 괜찮으니, 무엇이라도 만들어보자.
- 이 과정을 반복해가면 보다 복잡한 것을 만드는 능력이 몸에 베게 된다.

<br>



























