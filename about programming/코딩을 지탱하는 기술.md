

## 코딩을 지탱하는 기술

니시오 히로카즈

<br>

### 시작하며

- '변화하고 있는 지식'을 꾸준히 습득하지 않으면, 이미 학습한 지식도 점점 가치를 잃게 된다.
- 학습에는 3가지 중요한 포인트가 있다.
  1. 비교를 통한 학습
     다수의 언어를 비교하는 것이다. 
     무엇이 그 언어만이 가진 특유의 개념이고, 
     무엇이 언어 간에 공통으로 사용되는 개념인지를 배울 수 있다.
  2. 역사를 통한 학습
     언어의 발달 과정을 따라가는 것이다. 
     어떻게 탄생했고, 어떤 식으로 변화해 왔는지를 배움으로 
     '왜 이런 식으로 동작하고 있는지'에 대한 의문을 풀 수 있다.
  3. 만드는 것을 통한 학습
     직접 언어를 만드는 것이다. 
     '나라면 어떻게 만들까?'를 생각함으로, 
     언어 설계자의 의도를 쉽게 이해할 수 있게 된다. 
     또한 실제로 만들어봄으로써 자신이 잘 이해하지 못한 것을 알 수 있게 된다.
- 이 책의 목적은 '왜'를 해결하는 것이다.

<br>

### 역자의 글

- 개발자의 고통 중 하나는 새로운 프로그래밍 언어나 개발 환경이 출시될 때마다, 다시 새롭게 공부를 해야 한다는 것이다. 물론 공통적으로 사용되는 개념을 잘 이해하고 있다면, 새로운 프로그래밍 언어를 금방 사용할 수 있는 것도 사실이다.
- 아마 기존에 나와 있는 개발 언어 책 중에서 '클래스'에 관해 가장 알기 쉽고 명쾌하게 해설하고 있는 책이 아닌가 싶다.

------

<br>

### 1장

## 효율적으로 언어 배우기

- 개운치 않은 기분은 새롭게 배운 지식이 자신의 경험이나 본래 본인이 가지고 있던 지식과 연계되지 않을 때 생기게 된다.

<br>

### 1) 비교를 통한 배움

- 많은 언어에서 공통적으로 사용되는 개념이야말로 중요한 지식이다.
- 그 지식을 습득하게 되면 또 다른 언어를 배우는 것도 매우 수월할 것이다.

<br>

#### 규칙은 언어마다 다르다

- 복수의 언어를 비교해서 학습할 때 알게 되는 것이 있다. 그것은 '규칙은 언어마다 다르다'는 것이다.

<br>

#### C언어와 Ruby의 참거짓 값

- C언어를 배운 사람은 **'0이 거짓이고**, 그 이외의 값은 참이다'라고 알고 있을 것이다.
- C언어만 배웠다면 **'프로그래밍 언어에서는 일반적으로 0이 거짓이고**, 그 이외의 값은 참이다'라고 일반화하기 쉽다.
- 하지만 Ruby를 공부해보면 'Ruby에서는 0이 참이다'라는 것을 알고 놀랄 것이다.

```c
#include <stdio.h>

int main() {
  if (0) {
    printf("true!\n");
  } else {
    printf("false!\n");
  }
}	// false!
```

```ruby
if 0 then
  print "true!"
else
  print "false!"
end 	// true!
```

- 이 놀라운 사실은 잘못된 고정관념을 고칠 수 있는 기회를 준다.

<br>

#### Java의 참거짓 값

- Java에서는 참거짓 값을 위한 형을 가지고 있어서 조건식에서도 그 형을 사용하지 않으면 안 된다.
- 0은 단순히 정수형을 의미하기 때문에 조건식에 0을 사용하게 되면 컴파일 에러가 발생한다.
- 즉, 세상에는 0이 참인 언어, 0이 거짓인 언어, 0이 참도 거짓도 아닌 언어가 존재하고 있는 것이다.

<br>

### 2) 역사를 통한 배움

#### 언어 설계자의 의도를 이해하자

- 프로그래밍 언어가 가진 어떤 기능이 '어떤 의미인지' 설명을 읽고도 뭔가 개운치 않은 느낌을 받은 적이 있을 것이다. 그때 알고 싶은 그 기능이 '왜 필요한지'에 대한 대답일 것이다.
- 언어 설계자는 어떤 문제를 해결하기 위해 그 언어를 만든 것일까?
- 언어가 어떤 흐름을 따라 만들어졌는지 알게 되면 그 기능이 왜 필요한지 납득할 수 있게 된다.

<br>

#### 어떤 언어를 배워야 하는지는 아무도 모른다

- '프로그래밍을 배우고 싶은데 어떤 언어를 배우면 좋을까?'라는 질문은 무의미하다.

<br>

#### 언어에 의존하지 않는 보편적인 지식의 습득

- 개별 언어 지식이 5년 후, 10년 후에도 도움이 될지는 아무도 모른다.
- 몇 가지 언어를 비교하거나 언어의 역사나 이유를 조사함으로, 언어가 바뀌어도 통용할 수 있는 이해력을 기를 필요가 있다.

<br>

### 3) 정리

- '비교를 통한 배움'이란 특정 언어로 프로그래밍을 배우는 것이 아니라, 다수의 언어를 비교해 가면서 학습하는 것을 의미한다. 이를 통해, 무엇이 언어에 따라 다르고 무엇이 공통적인지 배울 수 있다.
- '역사를 통한 배움'이란 언어가 어떻게 바뀌었고 바뀌기 전에는 어떤 의문점이 존재했는지 학습하는 것을 의미한다. 이를 통해, 언어가 가지고 있는 다양한 기능이 '왜' 탄생했는지 배울 수 있다.

<br>

### 2장

## 프로그래밍 언어를 조감하다

- 프로그래밍 언어는 왜 탄생한 것일까?
- 무엇을 위해 프로그래밍 언어를 발명한 것일까?

<br>

### 1) 프로그래밍 언어 탄생의 역사

- 오래된 것과 새로운 것을 비교할 때 깊이 있는 이해가 가능하다.
- 많은 것이 과거의 것을 발전시켜 만들어졌다. 즉, 새로운 것은 과거의 것을 알고 난 후에야 만들어지는 것이다. 그러므로 옛날 사람 시점에서 생각하는 방법은 새로운 것을 배우는 사람에겐 매우 유리하게 작용한다.
- 프로그래밍 언어는 인간을 편하게 하기 위해 만들어졌다.

<br>

#### 케이블을 연결하다

- 1946년에 ENIAC (Electronic Numerical Integrator and Computer)이 발명됐다. 이 컴퓨터는 '무엇을 계산할지', 즉 목적에 따라 프로그램을 변경할 수 있었다. 지금으로 말하면 '프로그래밍'이 가능한 컴퓨터였다. 그러나 그 방법은 지금의 프로그래밍과는 매우 달랐다. 이 컴퓨터의 수많은 단자에 케이블을 여기저기 연결하는 것이 프로그래밍이었다.

<br>

#### 프로그램 내장 방식으로

- 1949년 EDSAC (Electronic Delay Storage Automatic Calculator)이 개발됐다. 이것은 테이프에 구멍을 뚫어서 데이터를 표현하고, 컴퓨터가 이를 읽어 들이도록 한 구조다. 프로그램 자체도 데이터로서 입력된다. 물리적 케이블을 교환하는 대신, 종이 테이프의 데이터를 읽어 들여서 프로그램을 변경할 수 있었다. 작업이 수월해졌다고는 하지만, 사람이 프로그램을 읽거나 쓰는 것은 여전히 어려웠다. 어디까지나 기계가 읽기 위한 언어, 즉 '기계어'였던 것이다. 입력에 사용하는 종이 테이프는 하나의 열에 데이터를 표현하기 위한 5개의 구멍과 종이를 이동시키기 위한 한 개의 구멍으로 구성되어 있었다. 오직 5개의 구멍만으로 프로그램을 표현해야 했다.

<br>

#### FORTRAN의 등장

- 1954년, 드디어 지금 사용하고 있는 것과 비슷한 프로그래밍 언어가 고안되었다. 바로 FORTRAN이다. FORTRAN이란 이름은 Formula Translating System(수식 변환 시스템)을 의미한다.지금은 프로그래밍 언어로 'x 곱하기 y 더하기 z'를 x * y + z라고 표현할 수 있는 것을 너무나 당연히 여기지만, 그것을 최초로 표현한 것이 FORTRAN이다. 명칭이 의미하듯 '수식을 기계어로 변환하는 것'이 FORTRAN의 특징 중 하나였다. 이 때는 효율이 높은 프로그램을 위해서는 사람이 기계어를 쓰는 수밖에 없다고 생각했다. 실제로 초기 FORTRAN 컴파일러가 출력하는 기계어는 능숙한 프로그래머가 짠 기계어에 비교하면 효율이 매우 떨어졌다. 그러나 코드량이 눈에 띄게 줄었고, 코드를 읽기 쉬워짐에 따라 많은 사용자층을 얻을 수 있었다.
- FORTRAN 설계자인 John Backus는 다음과 같이 말했다. '내가 이룬 성과의 대부분은 나태함에서 오고 있다. 나는 프로그램 짜는 것을 좋아하지 않았다. 그래서 프로그램을 쉽게 짤 수 있는 시스템을 만들었다.'

<br>

### 2) 프로그래밍 언어 탄생의 목적

- 프로그램은 어떤 것을 편하게 하기 위해 고안된 것이다. 편하게 하는 것은 부실하게 하는 것과는 다르다. 부실하게 만들어서 나중에 고생케 하는 것은 편하게 만들었다고 볼 수 없다.

<br>

#### 나태 - 프로그래머의 3대 미덕

- 프로그래밍 언어 Perl의 설계자인 Larry Wall은 저서 \<\<Programming Perl>>에서 프로그래머가 가져야 할 3가지 자질로서 '나태, 조바심, 자만심'을 제안했다. 이것이 프로그래머의 3대 미덕이라고 불린다.

  - 나태 (Laziness)
    전체 에너지 소비를 줄이기 위해 대부분의 능력을 집중하는 기질.
    이렇게 노동력을 줄이기 위해 만든 프로그램은 다른 사람들도 사용하게 되며,
    그 프로그램에 관한 질문에 일일이 답하는 수고를 덜기 위해 문서를 만들게 된다.
    이는 프로그래머에게 있어 가장 중요한 자질이기도 하며,
    이 책이 존재하는 이유이기도 하다.
    조바심과 자만심에 관해서도 참조할 것.

    \- \<\<Programming Perl 3rd edition>>

- 당장에 눈에 보이는 편리함을 요구하는 것이 아니라, 앞날까지 생각해서 가장 편한 방법을 선택하는 것이다. 즉, 같은 성과를 달성하는 다수의 방법 중 가장 생산성이 높은 것을 선택함을 의미한다.

- 이 책에 따르면 Perl이라는 이름은 'Practical extraction and report language'(실용적 데이터 취득 및 리포트 작성 언어)라는 의미다. Perl은 리포트 작성을 수월하게 하기 위해 만들어진 언어다.

<br>

#### 언어에 따라 다른 '편리함'의 의미

- 프로그래밍 언어의 목적은 '편리함'이라고 말했지만, 세상에는 왜 수많은 언어가 존재하는 것일까?

<br>

#### 무엇을 편하게 하고 싶은 것인가?

- 예를 들어 C++은 빠른 실행 속도를 중시하고 있는 언어다. C로 만든 코드보다 빠른 속도가 날 수 있도록 고안했지만, 결과적으로 언어 사양이 더 복잡해지고 말았다.
- 반면에, Scheme은 언어 사양을 쉽게 파악할 수 있는 데 중점을 두고 있는 언어다. 언어 사양이 최소한이 되도록 했고, 사양서 전체가 50페이지 밖에 되지 않는다. 그러나 구문이 수많은 괄호로 이루어져있어 싫어하는 사람도 많다.

<br>

#### 어떤 프로그램을 편하게 만들고 싶은가?

- Python은 다른 사람이 쓴 코드를 쉽게 해석할 수 있는 데 중점을 두고 있다. Scheme보다 C에 가깝고 프로그래머에게 익숙한 많은 제어 구문을 채용하고 있으며, 인텐드(Intend, 들여쓰기)를 강조하고 있다. 그에 반해 속도가 느리며, 사양도 단순하지 않다.
- PHP는 웹 서비스를 쉽게 만들 수 있도록 해준다. 그러나 문장 처리를 편하게 하지는 못한다.
- 올바른 설계는 사용하는 사람이 무엇을 목적으로 하고 있는지에 따라 달라진다.
- 다양한 설계 언어가 있는 것은 사람에 따라 다양한 목적이 있기 때문이다.
- 빠른 속도를 위해 만들어진 C++과 쉬운 코드 해석을 위해 설계된 Python을 비교해서 C++이 읽기 어렵다느니 Python이 느리다느니 하는 것은 유익하지 못한 논쟁이다.

<br>

### 3) 정리

- 프로그래밍 언어는 사람을 편하게 하기 위해 만들어졌다. 그러나 무엇이 편한지는 언어에 따라 다르다.
- 언어는 도구다. 어떤 언어가 자신의 목적에 적합한지는 그 언어를 사용할 때 자신이 어느 정도의 생산성을 발휘할 수 있는지로 판단할 수 있다.
- 자신이 어느 정도 성과를 낼 수 있는지를 고려해서 결정해야 한다.
- 좋은 도구를 현명하게 선택하여 적재적소에 사용하도록 하자.

<br>

### 3장

## 문법의 탄생

- 프로그래밍 언어에는 수많은 규칙이 있다. 무엇 때문에 많은 규칙이 존재하는 걸까?

<br>

### 1) 문법이란?

- 프로그래밍 언어에는 여러 가지 규칙이 있다.
- 문법이란, 프로그래밍 언어 설계자가 만든 '이렇게 쓰면 이런 의미로 해석된다'라고 정한 규칙이다.
- 문법이란 무엇을 편하게 하기 위해 만들어졌을까?
- FORTH라는 언어는 문법이 거의 없다.
- LISP라는 언어는 괄호로 코드 구조를 표현한다.
- FORTH와 LISP가 가지고 있는 기능은 현재의 프로그래밍 언어에서도 중요한 역할을 하고 있다.
- '문법과 구문의 차이점은 무엇일까?'라는 의문을 가질 수도 있다. 둘 다 프로그램을 만들기 위한 규칙이란 점은 같다. 단지 구문 쪽이 좀 더 좁은 범위를 가리키는 경우가 많다. 예를 들어 if 문을 구문이라고 부르는 것은 자연스럽지만, 연산자 우선순위를 구문이라고 부르는 것은 부자연스럽다.

<br>

#### 연산자 우선순위

- 연산자란 덧셈에 사용하는 +나 곱셈에 사용하는 *을 의미한다.

#### 문법은 언어 설계자가 정한 규칙

- 언어 설계자가 정한 규칙이 바로 문법이다.
- 문법은 언어에 따라 다르다.
- 연산자의 종류는 언어에 따라 다르다.
- 예를 들어 C언어에서는 '='가 연산자이며, 일반적인 가감승제와는 틀리게 '우결합성 연산자'이다. 그래서 소스 코드에 x=y=1이라고 써 있다면, 이것은 x=(y=1)이라고 해석된다.

<br>

### 2) 스택 머신과 FORTH

- FORTH는 1958년 경에 개발되어 문법이 거의 존재하지 않는 언어다.
- 설계자 Charles H. Moore에 따르면 'FORTH는 가장 간단한 컴퓨터 언어'이다. '세상의 모든 언어가 가독성이 있다고 주장하고 있지만, 처음 그 언어를 다루는 사람은 항상 당황한다. 이는 난해하고 변덕스러운 문법 때문이다. FORTH는 구문을 최대한 제한함으로 문제를 해결한다'는 것이 그의 주장이다.

<br>

#### 계산 순서

- FORTH에서는 '1과 2를 더한다'는 코드를 다음과 같이 쓴다.

```FORTH
1 2 +
```

- FORTH의 가장 큰 특징인 '스택(stack)', 즉 '값을 쌓아 두는 장소'를 사용한다.

<br>

#### 연산 순서를 어떻게 표현할까?

- '1과 2를 더한 것에 3을 곱하다'는 다음과 같이 표현할 수 있다.

```FORTH
1 2 + 3 *
```

<br>

- '2와 3을 곱한 후 1을 더한다'는 다음과 같이 표현할 수 있다.

```FORTH
2 3 * 1 +
```

- 거의 한국어 어순 그대로다.
- 만약 1, 2, 3의 순서가 중요하다면 다음과 같이 쓸 수도 있다.

```FORTH
1 2 3 * +
```

- '1과 (2와 3을 곱한 것을) 더한다'이다.
- 한국어로는 순서상 오류를 피하기 위해 어디까지가 한 구역인지 괄호를 사용했지만, FORTH에서는 괄호도 '우선순위라는 규칙'도 도입하지 않고 표현하고 있다.

<br>

### 3) 구문 트리와 LISP

- '하나의 구역을 표현하기 위해 항상 괄호를 사용하자'는 선택을 한 언어가 있다. 1958년에 탄생한 LISP이다.

<br>

#### 계산의 흐름

- LISP로 '1과 2를 더한다'는 코드는 다음과 같이 표현한다.

```LISP
(+ 1 2)
```

- 먼저 괄호로 시작해서 '더해'라는 명령이 앞에 나온다. 그 다음 공란으로 간격을 만들고 '무엇을 더할 것인지'를 쓴다. 

<br>

#### 계산 순서를 어떻게 표현할까?

- '1과 2를 더한 후 3을 곱한다'

```lisp
(* (+ 1 2) 3)
```

<br>

- FORTH에서도 LISP에서도 구문 트리는 동일하다.
- 실은 단순한 문법으로 이루어진 이 두 개의 언어는 특정 규칙을 사용해 구문 트리를 모방한 것뿐이다. 즉, 이 2가지 언어의 생김새는 크게 다르지만 동일한 구조를 사용해서 '하고자 하는 것'을 표현하고 있다.

<br>

#### 현재도 살아있는 구문 트리

- 구문 트리가 사용되고 있는 것은 최신 언어도 마찬가지다.
- Python에 기본으로 장착되어 있는 ast 라이브러리를 사용하면 특정 코드가 어떤 구문 트리로 구성되어 있는지 알 수 있다.
- ast는 abstract syntax tree의 약자다. 정확하게는 '추상 구문 트리'다. 복잡한 구문을 가지고 있는 언어에서는 '구문 트리' 자체가 수많은 구문으로 이루어져 이해하기 어렵다. 그래서 그것을 간단히 한 것이 추상 구문 트리다.

```python
>>> import ast
>>> ast.dump(ast.parse("1 + 2"))
Module(
  body=[Expr(
    value=BinOp(
      left=Num(n=1),
      op=Add(),
      right=Num(n=2))
  	)
  ]
)

>>> ast.dump(ast.parse("(1 + 2) * 3"))
Module(
  body=[Expr(
    value=BinOp(
      left=BinOp(
        left=Num(n=1),
        op=Add(),
        right=Num(n=2)
      ),
      op=Mult(),
      right=Num(n=3))
    )    
  ]
)
```

- **Binop op=Add()**는 '덧셈'을 의미하고, LISP의 '+'에 대응된다.
- **Num n=1**은 '수치 1'로, 이것은 LISP의 '1'에 대응된다.
- LISP는 문법이 간단해서 코드와 구문이 알기 쉽게 연결된다. 또한 '매크로'라는 구문 트리를 바꿔주는 메커니즘을 가지고 있어서, 구조체 프로그래밍과 같은 프로그래밍 언어의 발전에 큰 기여를 하게 된다.

<br>

### 4) 중위 표기법

- LISP에서는 '1 더하기 2'를 (+ 1 2)라고 표현한다. 연산자는 연산 대상의 앞에 배치된다.
- FORTH에서는 '1 더하기 2'를 1 2 +라고 표현한다. 연산자는 연산 대상의 뒤에 배치된다.
- 수식에서는 '1 더하기 2'를 1 + 2로 표현한다. 연산자는 연산 대상의 사이에 배치된다.
- 이와 같이 연산자를 연산 대상 뒤에 두는 것을 후위 표기법, 앞에 두는 것을 전위 표기법, 사이에 두는 것을 중위 표기법이라고 한다.
- 이 3가지 방법은 식을 표현하기 위한 약속에 불과하다. 하지만 프로그래밍 언어가 탄생하기 이전부터 사람들은 중위 표기법에 익숙했다.
- FORTRAN은 이 익숙한 방법을 적용할 수 있도록 만들어졌다. FORTRAN이란 이름이 Formula Translating System(수식 번역 시스템)의 약어인 이유도 이 때문이다.
- FORTRAN은 연산자 우선순위나 결합성 등 다양한 규칙을 도입해 문법을 만들었다. 그 결과, 프로그래머는 익숙한 방법으로 수식을 사용할 수 있게 되었다.

<br>

#### 구문 해석기

- 구문 해석기(파서, Parser)는 소스 코드를 문자열로 읽어 들여 해석하고, 그것을 구문 트리로 만드는 프로그램이다.
- FORTRAN에서 프로그램이 컴파일 될 때도 이 구문 해석기가 소스 코드를 문자열로 읽어 들여 구문 트리로 변환하는 작업을 하고 있다.
- 문법 설계와 구문 분석기 구현은 프로그래밍 언어의 외관을 결정하는 중요한 요소다.
- 언어 설계자는 문법을 설계할 때 무엇을 쉽게 쓸 수 있도록 할 것인지, 어떤 실수를 줄이도록 할 것인지 등 프로그래밍 언어가 사용자에게 어떤 가치를 줄 수 있을지 생각한다.

<br>

#### 규칙간 마찰

- 예를 들어 C++에서는 템플릿 기능을 추가할 대 vector\<int>와 같이 '부등호로 감싸는 표기'를 도입했다. 그러나 이 부등식 괄호를 이중으로 하면 괄호를 닫는 >>가 기존의 '쉬프트(shift) 연산자'로 해석되어버린다. 이 문제를 구문 분석기에서 해결하는 것이 쉽지 않아서 프로그래머가 공백 문자를 사이에 입력해서 >>가 되지 않도록 하는, 즉 운영 측면에서 문제를 해결하도록 했다.

```c++
// OK
vector<vector<int> > x;

// NG
vector<vector<int>> y;
```

- 물론 구문 분석기가 양쪽 구문을 문제없이 해석하도록 개선하는 것이 이상적이다. 그러나 현실은 이상과 다르다. 이것은 C++에 제한된 얘기가 아니다. 다른 언어에도 과거 규칙과의 마찰로 인해 부자연스러운 규칙이 생겨난 경우가 있다.

<br>

### 5) 정리

- 언어에 따라 표현 방법이 다르다. 그러나 구문 트리로 표현하면 거의 동일하다.
- 이들 언어에 차이가 생긴 것은 '어떤 문자열을 쓰면 어떤 구문 트리가 생기는가'라는 규칙이다. 이것이 문법이다.
- FORTH나 LISP는 규칙이 적은 것을 중시했다. 그러나 시장이 요구한 것은 규칙이 적거나 간단한 것이 아니었다.
- FORTRAN은 '*가 +보다 우선순위가 높다' 등의 정해진 규칙을 대량으로 도입해서 '다가가기 쉬운 작성법'을 중시했다. 그리고 그런 설계 방침의 성공으로, FORTRAN 방식이 LISP나 FORTH보다 많은 사람에게 사랑 받게 되었다.
- 현재 대부분의 프로그래밍 언어는 FORTRAN 식의 '다가가기 쉬운 작성법'을 목표로 하고 있다. 하지만 모순 없이 해석할 수 있는 문법을 만들어내는 것은 어려운 작업이다. 특히 나중에 새로운 문법을 추가할 때 기존 문법과 마찰되지 않도록 하는 것은 더욱 그렇다. 이 때문에 현실의 프로그래밍 언어에는 이해하기 어려운 작성법이 여전히 존재하는 것이다.

<br>

### 4장

## 처리 흐름 제어

- 프로그래밍 언어에는 if문, while문, for문 등 처리 흐름을 제어하기 위한 제어 구문이 존재한다.
- 왜 이런 제어 구문이 있는 것일까?

<br>

### 1) 구조화 프로그래밍의 탄생

- 1960년대 후반, '사람이 프로그램을 보다 편하게 쓰고 읽을 수 있도록 규칙을 만들자'는 흐름을 타고 '구조화 프로그래밍'이 태어났다. 자주 사용하고 있는 if문이나 while문 등의 규칙(구문)을 도입하여 코드 구조를 쉽게 만들자는 생각이었다.

<br>

### 2) if가 탄생하기 전

- if문 없이 어떻게 프로그램을 짜면 좋을까?

<br>

#### if는 왜 있는 걸까?

- 어셈블리어에는 if문이 없다. 그러나 어셈블리어는 C언어에서 간단히 변환(컴파일)된다. 그래서 if문을 사용한 코드를 C언어로 쓰고, 그것을 어셈블리어로 컴파일하도록 한다.
- C언어 소스는 다음과 같다. 'x가 456과 같으면 처리를 한다'는 코드다.

```c
int main() {
  int x = 123;
	  /* if문 앞 */
  if (x == 456) {
      /* if문 안 */
  }
      /* if문 뒤 */
}
```

- 컴파일하면 다음과 같은 어셈블리어 코드가 출력된다.

```assembly
_main:
		......
		mov1	$123, -8(%rbp)	#1
		# if문 앞
		mov1	-8(%rbp), %eax	#2
		cmp1	$456, %eax
		jne 	LBB1_2			#3
		# if문 안				   #4
LBB1_2:							#5
		#if문 뒤
		......
```

- -8(%rbp)는 원래 코드의 x라고 해석한다.
- \#1에서 x에 수치 123을 대입하고 있다.
- \#2에서 x의 값을 %eax라는 임시 저장소에 이동 후 수치 456과 비교한다.
- \#3이 중요한 부분으로, '바로 직전 비교에서 양쪽이 동일하지 않으면 LBB1_2로 점프'하라는 명령이다. 역으로 말하면, '양쪽이 동일하면 점프하지 않고 다음 명령을 실행한다'는 것이다.
- \#4가 if문 안쪽 코드로 양쪽이 동일할 때만 실행된다. 동일하지 않으면 LBB1_2(\#5)로 점프하기 때문에 \#4는 실행되지 않는다.
- 이와 같이 '조건을 만족하면 점프'라는 명령은 꽤 초기부터 존재했다.

<br>

#### If-else 사용의 장점

- '조건이 참인 경우와 거짓인 경우의 처리 흐름을 분배한다'는 패턴은 프로그래밍에 빈번히 사용된다. 이것을 간단하고 읽기 쉬운 형태로 쓰기 위해 if-else 구문이 새롭게 도입된 것이다.
- 프로그래밍을 하면서 else가 반드시 필요한 건 아니다. 하지만 사용했으면 좋겠다. 그게 더 편하게 읽을 수 있기 때문이다.

<br>

### 3) while, 반복되는 if를 읽기 쉽게 표현

- while 문은 '조건을 만족하고 있는 동안 블록 안의 내용을 반복하여 실행'하는 구문이다.

<br>

#### while 문을 사용하는 방법

- 다음 코드는 조건 x > 0을 만족하고 있는 동안 'x를 표시하고 x에서 1을 뺀다'는 처리를 반복한다.

```c
void use_while(int x) {
  printf("use_while\n");
  while (x > 0) {
    printf("%d\n", x);
    x--;
  }
}
```

<br>

#### while 문을 사용하지 않는 방법

- 앞서 다룬 처리가 while 문 없이 가능할까? 가능하다. 다음 코드는 '조건을 만족하지 않으면 END_LOOP에 점프', 'x를 표시하고 x에서 1을 뺀다', '조건문 직전으로 점프한다'는 내용이다.

```c
void not_use_while(int x) {
  printf("not_use_while\n");
}
```

<br>

- 많은 언어들이 루프(loop)를 중단하는 break 문을 가지고 있다. break 문을 실행하면 바로 루프를 빠져나간다. 이것은 goto END_LOOP와 같은 동작이다.
- while 문이 가져온 편리함은 '새로운 것'이 아니라, '읽기 쉽게 함', '쓰기 쉽게 함'인 것이다.
- goto는 강력하고 이해하기 쉬운 개념이다. 그러나 너무 원시적이다. 아무 생각 없이 goto를 남용하면 프로그램이 엉망진창이 되어버린다.
- if-else나 while, break는 '제한이 붙은 goto'라고 생각하면 된다.

<br>

### 4) for, 수치를 증가시키는 while을 읽기 쉽게 표현

- for 문으로 할 수 있는 것은 while 문으로도 가능하다.

<br>

#### for를 사용하는 방법

- 이것은 i를 0 이상 N 미만의 범위에서 1씩 증가시키며 표시하는 코드다.

```c
for (i = 0; i < N; i++) {
  printf("%d\n", i);
}
```

<br>

#### for를 사용하지 않는 방법

- 동일한 내용을 while 문을 사용해서 표현하면 다음과 같다.

```c
i = 0;
while (i < N) {
  printf("%d\n", i);
  i++;
}
```

<br>

- for 문을 사용하면 한 곳에 모두 정리가 되기 때문에 루프의 의도를 쉽게 이해할 수 있다.
- '시작값, 증가값, 종료값' 3가지를 함께 표현하는 for 문은 1958년에 만들어진 ALGOL 58에서 이미 발명된 것이다.

```ALGOL 58
for I : = 0 ( 1 ) N; ......
```

<br>

#### foreach, 처리 대상으로 반복 제어

- for 문이 다시 한 번 진화한 것이 현재 많은 언어에서 사용하고 있는 foreach 구문이다.
- Java에서는 확장 for 문이라고 불리고 있지만, Perl, PHP, C# 등 많은 언어에서 foreach라는 이름으로 불리고 있다.
- for 문과의 구분을 위해 foreach 구문이라고 부르겠다.
- while 문은 조건식으로 반복을 제어한다.
- for 문은 횟수로 반복을 제어한다.
- foreach 구문은 처리 대상으로 반복을 제어한다.
- foreach 구문은 '어떤 대상의 요소 전부에 어떤 처리를 한다'는 코드를 쉽게 쓰기 위해 만들어졌다.

```java
// 배열
int[] items = new int[]{1, 2, 3, 4, 5};

// 일반 for 문으로 각 요소를 출력
for (int i = 0; i < items.length; i++) {
  int item = items[i];
  System.out.printIn(item);
}

// 확장 for 문으로 각 요소를 출력
for (int item: items) {
  System.out.printIn(item);
}
```

- for 문에서는 '0 이상 items 크기 미만의 범위에서 i를 1씩 증가시키면서 items의 i번째를 표시'라고 표현하고 있지만, foreach 구문을 사용하면 'items의 각 요소를 표시'라고 간단하게 쓰고 있다.

<br>

### 5) 정리

- if 문, while 문, for 문 등의 처리 흐름을 제어하기 위한 규칙(문법)에 대해 배웠다.
- if 문, while 문, for 문을 사용하지 않아도 프로그램을 짤 수 있다.
- 그러나 사용하는 것이 보다 알기 쉬운 코드를 구성할 수 있다.

<br>

### 5장

## 함수

- 함수는 왜 생겨난 것일까?

<br>

#### 1) 함수의 역할

- 함수, 즉 '코드의 일부를 한 덩어리로 잘라내어 그것에 이름을 붙이는 기능'이다.
- 함수는 왜 필요했던 걸까? 함수가 없어도 구현할 수 있지만, 함수를 사용하는 게 보다 편하다.

<br>

#### 이해 (조직을 예로)

- 코드가 함수로 나눠져 있는 것은 큰 조직이 부서로 나눠져 있는 것과 닮았다. 사람 수가 적으면 그룹 전원의 얼굴과 이름, 특기 등을 쉽게 파악할 수 있다. 그와 마찬가지로, 코드도 행수가 적으면 어디서 무엇을 하고 있는지 간단히 파악할 수 있다. 문제는 사람 수가 늘었을 때다. 그래서 몇 명을 하나의 그룹으로 묶어서 이름을 붙이게 된다. 프로그래밍도 동일하다. 소스 코드의 행수가 많아지면 전체를 파악하기 어렵게 된다. 그래서 몇 개의 행을 하나의 그룹을 묶어서 거기에 이름을 붙이는 것이다. 이것이 함수다.

<br>

#### 재사용 (부품을 예로)

- 함수를 만드는 것은 작은 부품을 조립해서 큰 부품을 만드는 것과 비슷하다. 함수도 동일하다. 수십 행, 수백 행의 코드가 함수로 정리되어 제공되고 있어서 쉽게 그 함수를 호출해서 사용할 수 있다. 전지의 구조를 상세히 알지 못해도 '전지는 전기를 만들어 내는 것이다'라는 지식만으로 무선 조정 자동차를 조립할 수 있다. 이것은 함수가 이해를 도와주는 것과 비슷하다.

<br>

#### 프로그램 재사용의 특징

- 프로그램을 만드는 것과 물리적인 것을 만드는 것에는 크게 다른 점이 하나 있다. 그것은 부품을 재사용하고 싶을 때 드는 비용이다.
- 프로그램으로 리스트 안에 있는 모든 데이터를 어떤 함수로 처리하고 싶다면, 데이터가 100개 있으면 그 함수를 100회 부르면 된다. 200개 있으면 함수를 200회 부른다. 데이터 양이 늘어난 만큼 실행 시간이 소비된다. 그러나 함수는 한 개만 만들면 된다. 200회를 호출한다고 해서 200개를 만들 필요가 없다. 몇 번이고 사용할 수 있는 처리를 함수로 정리해서 몇 번이고 호출해서 사용하여 소스 코드를 간결하게 유지할 수 있다.
- 같은 처리를 한 군데에 정리하여 생기는 이점은 단순히 프로그램이 짧아지는 데에만 있지 않다. 소스 코드를 읽는 사람이 몇 번이고 같은 내용의 소스 코드를 읽을 필요도 없어진다. 길게 늘려있는 명령들을 자주 사용되는 단위로 잘라내어 정리함으로써 프로그램을 보다 쉽게 이해할 수 있게 된다.

<br>

### 2) 돌아가는 명령

- 소스 코드를 재사용하기 위해서는 goto 문만으로는 역부족이다.
- goto 문으로 못하는 것, 그것은 바로 '원래 위치로 돌아가'는 것이다. 점프할 때 '어디에서 점프해 왔는지'를 기억해두고, 나중에 '돌아가'라는 명령을 만나면 점프 명령 직후로 점프하게 하고 싶은 것이다. 이 '원래 위치로 돌아가'라는 명령이 가능하면 코드를 재사용할 수 있게 된다. 하나의 프로그램 안에서 동일한 처리가 여러 번 이루어지면 그것을 한 곳에 모아두는 것이 가능하다.

<br>

#### 함수의 탄생

- 1949년 EDSAC에서 함수를 호출한 후 원래 위치로 돌아오는 것을 점프 명령의 목적지를 변경해서 구현했었다.

  - 1: 110의 점프 명령의 점프 목적지를 3으로 바꾼다.
  - 2: 함수를 호출한다 (100으로 점프)
  - 3: 다음 명령
  - …...
  - 51: 110의 점프 명령의 점프 목적지를 53으로 바꾼다.
  - 52: 함수 호출 (100으로 점프)
  - 53: 다음 명령
  - …...
  - 100: 함수 처리
  - …...
  - 110: 돌아간다 (0으로 점프)

  이렇게 해서 함수가 탄생했다.

<br>

#### 돌아갈 목적지를 기록하기 위한 전용 메모리

- 함수 호출 전으로 돌아가도록 하는 명령의 점프 목적지를 변경하기 위해, 함수를 호출하는 사람이 '점프 목적지가 어딘지', '돌아가는 명령이 있는 곳은 어디인지'를 상호간에 파악해둬야만 했다. 예를 들어, 함수 내용을 조금 바꿔서 돌아가는 명령의 위치가 뒤로 옮겨졌다고 치자. 그러면 그 함수를 호출하고 있는 코드를 전부 수정해야만 한다.
- 조금 더 개선된 방법이 발명되었다. 돌아갈 목적지를 기록해두는 전용 메모리를 만들어 '돌아갈 목적지 메모리에 적어둔 번지로 점프하는 명령'을 준비해두는 방법이다. 이것으로 호출처가 '돌아가는 명령의 위치'를 파악해둘 필요가 없어졌다.
  - 1: '돌아갈 목적지 메모리'에 3을 넣는다
  - 2: 함수 호출 (100으로 점프)
  - 3: 다음 명령
  - …...
  - 100: 함수 처리
  - …...
  - 110: 돌아갈 목적지 메모리에 써 있는 지번으로 돌아간다
    그러나 이 방법에는 문제가 있다. 함수 X를 호출하고 있는 중에 다른 함수 Y를 호출하면, 돌아갈 목적지 메모리에 덮어 씌워져서 함수 X가 돌아갈 목적지를 잊어버리게 된다. 어떻게 하면 좋을까?

<br>

#### 스택 (Stack)

- 스택은 복수의 값을 저장해두는 데이터 구조로, 마지막에 넣은 것을 가장 먼저 꺼내는 경우에 적합하다.
- '스택의 머리(마지막에 넣은 데이터)가 어딘지'를 기록해두는 메모리 위치를 정한다. 새로운 데이터를 기록할 때는 그 값을 1 증가시킨 후, 거기에 적혀 있는 번지에 데이터를 기록한다.
- 함수 X를 호출하고 있는 중에 함수 Y가 호출되어도, 함수 X가 돌아갈 목적지가 살아있어서 제대로 돌아갈 수 있다.

<br>

### 3) 재귀 호출

- 재귀 호출이란 함수 X 안에서 함수 X 자신을 호출하는 것이다.
- 지금은 대부분의 언어가 채용하고 있는 코딩 기술이다.

<br>

#### 내포 구조 데이터의 효율적 처리

- 재귀 호출은 꼭 필요한 것일까? 물론 그렇지 않다. 재귀 호출을 사용하고 있는 프로그램을 재귀 호출 없이도 만들 수 있다.
- 어떠한 처리를 재귀 호출을 사용해 만들면 매우 편하게 구현할 수 있다.
- '어떤 처리를 하고 있는 도중에 동일한 처리를 다른 대상(인수)에 대해 실행한다'는 내포(nesting) 형태의 처리다. 내포된 데이터 구조를 다룰 때는 코드도 함유 구조가 되는 경우가 많다.

<br>

#### 내포 구조를 다루는 방법

- 내포된 처리를 예로 해서, 내포된 리스트의 수치를 전부 합산하는 문제를 생각해보자.
- 예를 들어 [1, 2, [3, 4], 5]라는 리스트를 생각해보자. 이것은 [1, 2, ?, 5]라는 리스트의 ? 부분에 [3, 4]라는 별도의 리스트가 내포되어 있다. 이 내포 리스트에 있는 숫자를 전부 합산하고 싶을 때는 어떻게 하면 될까?
- 다음의 Python 코드에서는 for 문으로 리스트에서 하나씩 꺼내, 그것이 정수이면 합산해가는 처리를 하고 있다.

```python
def total(xs):
  result = 0
  for x in xs:
    # 리스트 xs에서 요소를 하나씩 꺼내 x라고 한다.
    if is_integer(x):
      # x가 정수이면 더한다
      result += x
	else:
      # x가 정수가 아니면 무엇을 할까?
  return result
```

- 우선 '1'과 '2'가 나오며 정수이기 때문에 result에 더한다. 여기까지의 합은 3이다. 여기까지는 간단하지만 다음에는 정수가 아닌 [3, 4]가 나온다.

<br>

#### for로 구현할 수 없다

- 입력 데이터의 리스트가 가장 깊은 곳이 2중 내포이기 때문에 2중 for 문으로 처리할 수 있다. 하지만 3중 내포의 리스트가 입력되면 어떻게 될까? 두 번재 for 문을 처리하고 있을 때 다시 리스트가 출현한다. 이 리스트는 어떻게 하면 좋을까?

```python
def total(xs):
  result = 0
  for x in xs:
    if is_integer(x):
      result += x
    else:
      	# x가 리스트이기 때문에 for 문으로 돌린다.
        for y in x:
          if is_integer(y):
            result += y
        else:
          # 추가로 리스트가 나오면 어떻게 하면 좋지?
  return result
```

- 여기에 추가로 for 문을 써도 '3중 내포까지 처리 가능한 코드' 밖에 되지 않는다.
- 이런 '수많은 내포 관계로 된 데이터 구조'는 결코 놀라운 것이 아니다. 예를 들어, HTML에서는 태그가 수십 개의 내포 관계로 되어 있다. 이런 데이터 구조를 다루기 위해서는 다중 내포 관계에서도 사용할 수 있는 코드여야 된다. for 문을 몇 개의 내포 관계로 구성한다고 해도 해결할 수 없다.

<br>

#### 재귀 호출을 사용

- 그래서 존재하는 것이 재귀 호출이다.
- 재귀 호출을 사용해서 total을 완성해보자.

```python
def total(xs):
  result = 0
  for x in xs:
    if is_integer(x):
      result += x
    else:
      # x는 내포 리스트이기 때문에 total로 안에 든 값을 합산한다.
      	result += total(x)
  return result
```

- 이것으로 완성이다. 함수 total은 몇 중으로 된 내포 리스트가 전달되어도 안에 있는 모든 수를 합산할 수 있도록 되었다.

<br>

#### 재귀 호출의 처리 흐름

- 재귀 호출이 실행되는 과정을 순서대로 확인해보자.
  1. 우선 total이 [1, [2, 3], 4]라는 인수를 가지고 호출되며, 이때 xs는 [1, [2, 3], 4], result는 0이 된다.
  2. 그리고 for 문의 루프가 시작된다. 우선 xs의 최초값을 꺼낸다. 이것은 정수 1이기 때문에 result에 1을 더한다. result는 0에서 1로 바뀐다.
  3. 그리고 루프는 다음 요소로 넘어간다. xs의 2번째 요소를 꺼내보면 [2, 3]이기 때문에 정수가 아니다. 리스트 합을 구하기 위해서 [2, 3]을 인수로 사용해 total 함수를 호출한다. 두 번째 total 함수 호출에서는 xs가 [2, 3]으로, result는 0이 된다.
  4. 두 번째 호출 안에서 for 문의 루프가 시작된다. xs의 최초값을 꺼내면 정수값인 2이기 때문에 result에 2를 더한다. result는 0에서 2가 된다.
  5. 두 번재 호출 안에 있는 for 문이 계속된다. xs의 두 번째 요소를 꺼낸다. 이것은 정수 3이기 때문에 result에 3을 더한다. result는 2에서 5로 바뀐다.
  6. 이것으로 두 번째 호출문 안에 있는 for 문의 루프가 종료된다. 루프를 빠져나오면 return result가 있어서 현재 result 값인 5를 반환한다. 호출처에서는 반환값을 result에 더한다. result는 1에서 6으로 바뀐다.
  7. xs의 3번째 요소를 꺼낸다. 이것은 정수 4이기 때문에 result에 4를 더한다. result는 6에서 10으로 변경된다.
  8. 이것으로 total의 첫 번째 호출 안에 있는 for 문이 종료된다. result 값이 10이기 때문에, 10을 호출처로 반환한다.
- 함수 호출마다 개별적으로 xs나 result 등의 값을 기억하는 장소가 있다는 것과, 두 번째 total 처리가 완료됐을 때 첫 번째 total 처리는 아직 계속 진행되고 있는 것 등은 자칫하면 놓치기 쉬운 포인트다.

<br>

### 4) 정리

- 프로그램의 규모가 커지면 전체적인 구조를 파악하기 어려워진다.
- 비슷한 처리를 몇 번이고 반복해서 쓰고 싶어지는 경우도 생긴다.
- 함수는 이 문제를 해결하기 위해 탄생했다.
- 한 그룹인 코드를 빼내어 의미 있는 이름을 붙여서, 그 코드가 무엇을 하고 있는지 파악하기 쉬워진다. 그리고 그 함수를 다른 장소에서 호출하여 사용함으로 재사용도 가능해진다.
- 함수를 사용함으로 '재귀 호출'이라는 코딩 기술이 탄생했다. 이것은 내포 구조로 된 데이터를 다루기에 적합한 기법이다.

<br>

### 6장

## 에러 처리

- 프로그램 실행 시 실패가 발생하는 경우가 있다. 실패 시에 어떻게 하는가(에러 처리)는 매우 중요하다.

<br>

### 1) 프로그램도 실패를 한다

- ​















------

### 칼럼

#### 이해력을 확인하기 위해서는 결과물(output)을 확인한다

- 어떤 것을 공부해서 '이해했다'고 치자. 그것은 '정말 이해했다'일까 아니면 '이해했다라고 착각했다'일까?
- 이해한 것이 맞는지를 확인하기 위해서는 결과물(output)이 필요하다. 
- 자신이 이해한 것을 정리해서 그것을 제3자에게 검증을 받는 수밖에 없다.
- 프로그래머는 이런 점에서는 혜택을 받고 있다. 프로그래밍 언어의 결과물은 언어 처리계가 틀린 곳을 자세히 지적해준다.
- 그것을 이해하려 하지 않고서는 언어 처리계와 제대로 된 커뮤니케이션을 할 수가 없다.

<br>

#### 무엇을 배우면 좋을지 모르는 이유

- '무엇을 배우면 좋습니까?' 이는 자주 듣는 질문이다. 이 질문에 대답하기 전에 한 가지를 물어보고 싶다. '무엇을 만들고 싶은가요?' 목적이 명확하지 않으면 최선의 방법 또한 가르쳐줄 수 없다.
- '어쨌든 전부 다 한 번은 공부해보자'는 전략은 어리석다.
- '무엇을 배울지, 무엇을 배우면 좋을지'를 정할 때 필연적으로 지표가 될 수 있는 것이 '무엇을 만들고 싶은가?', 즉 목적을 명확히 하는 것이다. 
- 목적을 달성하기 위해 필요한 것부터 배우면 된다.
- '무엇을 만들까?'를 결정할 수 없다면, 처음부터 완벽한 것을 만들려고 생각하고 있는 것은 아닌지 고민해보자.
- 처음부터 굉장한 것을 만들려고 생각해서 오히려 손도 대지 못하고 있다면, 시간이 흘러도 굉장한 것을 만들 수 없다. 우선은 간단한 것도 괜찮으니, 무엇이라도 만들어보자.
- 이 과정을 반복해가면 보다 복잡한 것을 만드는 능력이 몸에 베게 된다.

<br>

#### 이름

- 함수를 사용한 처리에 이름을 붙이는 행위는 '처리가 시작되는 메모리상의 위치'를 수치로 표현하는 대신, 알기 쉬운 문자열로 표현하는 행위다. 이것은 변수도 마찬가지다. 변수도 '값이 기록된 메모리 위치'를 수치가 아닌 문자열로 표현하기 위해 만들어졌다.

<br>



























