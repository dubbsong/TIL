## 프로그램, 프로그래밍, 프로그래머

\- 김창준 중앙대 컴퓨터공학과

<br>

- 자신의 모드를 고수하며 유행에 물들지 않고 나름의 지속적 변화를 꾀하는 디자이너는 소수다. 그들이 세상을 바꾼다.

<br>

#### 어원학적 고찰

- 곰브리치(E. H. Gombrich)의 \<예술 이야기(The Story of Art)>의 서두부터가 심상치 않다. `"사실 예술이라고 하는 것은 없다. 오로지 예술가들이 있을 뿐이다."` 곰브리치는 대명사로서의 예술, 즉 첫 글자가 대문자인 예술(Art)을 지칭한 것이다. 이것은 어떤 고정적이고 단일한, 천상 어딘가에 그 완벽한 원형이 고이 간직되어 있을 존재로서의 예술은 없음을 의미한다.
- '과정'으로서의 '프로그래밍'이란 무엇이고, 거기서 나오는 '결과'로서의 '프로그램'은 무엇이며, 이 작업을 행하는 '주체'로서 '프로그래머'란 누구인가.
- '프로그램(program)'이라는 단어는 '미리 쓴다', 즉 뭔가를 미리 써서 알리는 '사전 고지'를 의미했다. 이것은 미리 계획을 세워서 알리는 개념으로 발전했고 나중에는 그 계획 자체를 뜻하게 되었고, 1920년대 기술의 발전으로 라디오가 탄생하면서 라디오 진행표를 일컫는데 사용되기에 이르렀다.
- 우리가 말하는 컴퓨터 프로그램으로서의 '프로그램'이 최초로 등장한 것은 1946년 네이처(Nature)의 에니악(ENIAC) 컴퓨터 관련 기사였다.
- 프로그래머란 프로그램을 만드는 사람을 말한다.
- 프로그래밍이란 프로그램을 만드는 작업을 말한다.
- 프로그램이란 "문제 해결의 단계를 코드화해 표현한 것"이라고 하면 어떨까.
- 일반적인 의미에서 프로그래머는 '문제 해결자'라고 말할 수 있다.
- 자신이 설령, 시스템 분석가나 아키텍트가 던져주는 문서를 보고 단순 노동으로 프로그래밍하는 사람일지라도 자존심을 가져라. 이미 그들은 '일반적 문제 해결자(general problem solver)'의 배경과 가능성을 갖고 있는 것이나 마찬가지이기 때문이다.

<br>

#### 같은 뜻, 다른 표현

- 문제를 해결한다는 것은 무엇인가.
- 모든 수학 문제는 기본적으로 경험적이 아니라 분석적이다. 그것은 세종대왕이 한글을 창제한 해와 같이 어떤 직간접 경험을 통해 알 수 있는 것이 아니고, 그 문제 자체와 몇 가지의 수학적 공리를 분석하면 선험적으로 알 수 있다는 말이다. 한마디로 문제를 완벽하게 이해하고, 기본이 되는 공리를 알고 있다면 답을 알 수밖에 없다는 것과 같다.
- 모든 수학문제의 답은 문제의 조건을 변형한 것으로 귀착된다.

<br>

#### 컴퓨터의 이론적 배경

- 기본적으로 문제를 푼다, 계산한다(compute)고 하는 것은 수학적인 의미에서의 함수를 말한다. 어떤 값 x를 f(x)라는 함수에 입력했을 때 그 결과값이 무엇인지를 알아내는 것이다. 여기서 x는 단순히 숫자만이 아니라 훨씬 다양한 대상(글자, 문장, 그림 등)이 될 수 있다. 물론 컴퓨터는 이를 단지 기호(symbol)의 일종으로만 여길 뿐이다.
- 오늘날 컴퓨터의 실질적 모델은 폰 노이만 구조(Van Neuman Architecture)를 따른다. 폰 노이만 구조는 기억 장치(메모리)에 자료(데이터)와 명령어를 함께 저장하고, 중앙 처리 장치가 그 저장된 프로그램의 명령어를 하나씩 읽어와서 자료에 대해 연산하는 구조를 말한다.
- 컴퓨터는 근본적으로 오직 한 가지 언어만을 이해한다. 우리는 이것을 기계어라고 부른다. 이 언어는 2진수로 표현되고, 명령어(연산자)와 목적어(피연산자)가 짝을 이룬다. 예를 들어, 기억 장소의 세 번째 칸에 있는 값을 하나 증가시키라는 식이다.
- 인간은 2진수로 표현된 명령어와 자료를 이해하기 힘들다. 따라서 좀 더 인간의 자연 언어에 가까운 언어를 개발해 사용하게 된다. 이를 고수준 언어라고 부른다. 하지만 컴퓨터는 이것을 이해하지 못하기 때문에 번역의 과정이 필요하다. 고수준 언어로 된 프로그램 전체를 한번에 기계어로 번역해 이를 차후에 다시 사용할 수 있게 저장하는 것을 컴파일(compile)이라고 하고, 한 문장씩 번역해 순서대로 실행하는 것을 인터프리트(interpret)라고 한다.
- 고수준 언어에서 명령어 하나는 저수준 언어(기계어)의 명령어 수 십 개에서 수 천 개 이상으로 구성된 것이다.

<br>

#### 컴퓨터 세계의 어족

- 눈이 많이 내리는 지방에는 눈과 관련된 표현이 발달하고 추상화(경제적 의미에서)가 많이 진행되는 반면, 사막 지방에는 낙타와 관련된 단어가 많다.
- 프로그래밍 패러다임은 크게 네 가지 범주를 벗어나지 않는다.
  - 명령형 (imperative)
  - 함수형 (functional)
  - 논리형 (logic)
  - 객체지향형 (object-oriented)
- 기계어로 번역될 것임에도 불구하고 기계어 대신 고수준 언어(3세대 언어)를 사용하는 것은 이것이 인간에게 더욱 가깝고, 추상화가 잘 돼 있어 자잘한 것들에 신경 쓸 필요가 없기 때문이다.
- "밥을 먹어" 대신에 "수저에 밥알 220알을 펴서 상방 30도 각도로 올린 다음 입안에 넣고 씹는 운동을 하는 것을 밥그릇이 빌 때까지 반복하라"는 명령을 해야 한다는 것은 악몽이다.
- 각 언어의 표현능력이 동등함에도 불구하고 여러 언어가 존재하는 것은 각 문제와 상황에 더욱 적당한 언어가 있기 때문이다. 따라서 여러 가지 도구를 다룰 줄 알면서 상황에 맞게 적절한 것을 골라 쓰는 장인의 지혜가 필요하다.

<br>

#### 프로그래밍 언어와 사고

- 언어는 틀이고 툴(tool)이다. 인식의 도구이자 인간을 종속시킨다(우리는 사용하면서 동시에 지배받는다).우리는 언어로 세계를 형성하고 이해한다.
- 어떤 언어를 사용한다는 것은 그 사람에게 사고의 어떤 틀을 제공한다는 말과 같다.
- 한 가지 언어를 배운다는 것은 그 언어를 사용하는 사람들의 사고 구조를 몸에 익힌다는 말과 크게 다르지 않다. 영어를 배운다면 영어를 사용하는 사람들의 사고 구조가 몸에 익도록 해야 한다.

#### <br>

#### 과학자, 장인, 예술가

- 자신의 몸의 훈련을 통해 도구를 마치 몸의 연장처럼 만들되, 하나의 도구에만 종속되지 않으며 재료에 알맞게 다양한 도구를 선택할 수 있어야 한다. 자신이 만드는 프로그램 하나 하나에 누가 감시하든 말든 성실하게 최선을 다하고 그것을 내 몸과 같이 아끼고 사랑할 수 있어야 비로소 '장인(artisan)으로서의 프로그래머'가 될 수 있다.
- 프로그래머는 예술가(artist)의 역할도 할 수 있어야 한다.

<br>

#### 훌륭한 프로그램과 프로그래머

- 훌륭한 프로그래머는 어떤 사람일까.
- 프로그래머는 프로그램으로 말한다. 이들은 오로지 프로그램(결과)과 프로그래밍(과정)으로 평가받기를 원한다. 그렇다면 훌륭한 프로그래머란 바람직한 프로그래밍을 통해 훌륭한 프로그램을 만들어 내는 사람일 것이다.
- 프로그램이라는 결과물에는 그 사람이 작업한 과정은 잘 드러나지 않는다.
- 좋은 프로그램이 되기 위한 조건들
  - 스펙 (Specification)
  - 스케줄
  - 적응성
  - 효율성
  - 경제성
- 프로그래밍의 목적은 '문제 해결'이요, '일을 해 내는 것'이다.
- 좋은 프로그램의 가장 기본적인 요구사항은 '해야 할 일을 하는 것'이다. 이것이 가장 중요한 '스펙'이라는 사항이다. 프로그램은 모든 요구조건을 만족해야 한다.
- 스케줄은 '시간 안에' 프로그램을 만들어 내는 것을 말한다.
- '상황에 맞게' 적절히 갖춘 프로그램을 생산해 낼 수 있는 사람, 우리는 그들을 '훌륭한 프로그래머'라고 부른다.

<br>

#### 프로그래머가 알아야 할 것

- 핵심 지식
  - 소프트웨어 설계 (Design)
  - 구축 (Construction)
  - 테스팅 (Testing)
  - 형상 관리 (Configuration)
  - 품질 공학 (Quality Engineering)
  - 프로세스 (Process) 관리
- 전문가들이 생각하는 가장 중요한 주제
  - 특정 프로그래밍 언어들
  - 자료구조
  - 소프트웨어 디자인과 패턴
  - 소프트웨어 아키텍처
  - 요구사항 수집 및 분석
  - HCI(Human Computer Interaction) 및 유저 인터페이스
  - 객체 지향 기술 및 개념
  - 직업윤리와 프로페셔널리즘
  - 분석 및 디자인 방법
  - 청중에게 프레젠테이션하는 것
  - 프로젝트 관리
  - 테스팅, 검증 및 QA(Quality Assurance)
  - 알고리즘 설계
  - 기술적 글쓰기 (Technical Writing)
  - 운영체제
  - 데이터베이스
  - 리더쉽
  - 형상 및 릴리즈 관리
  - 데이터 전송과 네트워크
  - 경영
- 학교에서 가르쳐 주지 않았지만 실전에서 중요한 것
  - 소프트웨어 디자인과 패턴
  - 소프트웨어 아키텍처
  - 요구사항 분석
  - HCI 및 유저 인터페이스
  - 프로젝트 관리
  - 테스팅 및 QA
  - 형상관리
- 업계에 종사하면서 중요하다고 여겨지는 것
  - 협상 (Negotiation)
  - 리더십
  - 유저 인터페이스
  - 요구분석
  - 직업윤리와 프로페셔널리즘
- 비전공자들이 가장 많이 배워야 했던 것
  - 특정 프로그래밍 언어들
  - 자료구조
  - 테스팅
  - 검증 및 QA
  - 운영체제
  - 소프트웨어 디자인 및 패턴
  - 객체지향 기술 및 개념
  - 데이터베이스
  - 형상관리
  - 직업윤리 및 프로페셔널리즘
- 이런 전체 그림을 항상 옆에 두고 자신의 지식을 관리하며, 구체적인 지식과 동시에 일반적이고 좀 더 오래 지속할 '핵심'을 함께 구유하는 데 힘써야 할 것이다.

<br>

#### 프로그래머의 지식 투자

- 지식 투자 관리는 어떤 면에서 재무 투자 관리와 상당히 유사하다.
  - 정기적으로 투자하는 것을 습관화한다.
  - 분산 투자가 장기 성공의 열쇠다.
  - 자신의 포트폴리오를 안전한 것과 위험성이 큰 것을 고루 갖추도록 균형을 잡는다.
  - 싸게 사서 비싸게 판다.
  - 주기적으로 포트폴리오를 재평가한다.
- 지금 당장 필요하지 않은 언어를 배우면서 자꾸 의혹 속에 괴로워하지 마라. 설령 그 언어를 사용하지 않더라도 다른 문제 해결에 분명 도움이 될 것이다.
- 안정성이 보장되는 지식만 좇는 것이나, 위험성이 너무 큰 (실효가 입증되지 않은) 지식만 추구하는 것은 모두 문제가 있다. 균형을 유지해야 한다.
- 서점에 널린 기술은 이미 비싸게 사서 싸게 팔 확률이 높은 것들이다.
- 가장 중요한 것은 '자신의 포트폴리오에의 정기적인 투자'다.

<br>

#### 프로그래머의 자기 수련 서적

- 유행과 동떨어졌기에 유행에서 살아남을 수 있었던 것이리라.
- 전문 프로그래머라면 항상 기술 중심적이고 구체적인 책을 한 손에 들고 공부하면서도, 일반적이고 유행과 상관없는 책을 다른 손에서 놓치지 않아야 할 것이다.
  - The Art Of Computer Programming / Knuth
    알고리즘과 자료구조에 관한 최고의 책이다. 프로그래머로서 정말 충실하게 공부해둬야만 나중에 좌절을 맛보는 경험을 피할 수 있다. 읽을 자신이 없다면 최소한 이 책들의 목차만이라도 봐두자.
  - Programming Pearls / Bentley
    실질적인 코드(C, C++)와 함께 알고리즘 개선, 코드 최적화 등을 다룬다. 현재 프로젝트에서 알고리즘이나 자료구조에서 문제가 생기면 일단 마음을 차분히 가라앉히고 조용한 곳에서 이 책을 읽어보라.
  - Structure and Interpreatation of Computer Programs / Abelson
    미국 MIT 대학에서 10년이 넘도록 입문코스용 교과서로 사용되고 있는 유명한 고전이다. Scheme이라는 그다지 대중적이지 못한 언어를 사용했지만, 이 책은 여전히 고전으로서 가치가 빛나고 있다. 겉 표지에 마법사 그림이 있어서 마법사 책이라고 불린다.
  - Design Patterns / Gamma
    하나의 디자인 패턴은 특정한 종류의 문제를 해결하는, 프로그래밍 언어보다는 좀 더 추상적인 차원에서 일반적인 방법을 서술한다.
  - A Pattern Language: Towns, Building, Construction / Alexander
    패턴 언어는 원래 건축학에서 온 개념이다. 건물을 짓는 것과 소프트웨어를 만드는 것 간에는 상당한 유사점이 있다. 이것을 읽는다면 세상을 보는 관점이 바뀔 것이다.
  - How Buildings Learn: What Happens After They're Built / Brand
    건축학적인 개념에서 어떻게 건물이 '진화'하고 스스로 변화시켜 나가는지를 보여주며, 진화하기 좋은 건축물은 어떤 것인가에 대한 진지한 고찰이 들어있다. 프로그래머들이 고민하는 문제와 동일하다.
  - The Mythical Man-Month: Essays on Software Engineering / Brooks
    더 이상 설명할 필요가 없는 책이다. 진행 중인 프로젝트 팀에 더 많은 인원을 쏟아부으면 오히려 제품 출시가 더욱 늦어진다는 점을 밝힌 것으로 유명하다. 소프트웨어 공학에 관심이 없거나 기반 지식이 전무한 사람도 읽어볼 만한 책이다.
  - Code Complete / McConnell
    소프트웨어 구축 과정에 관한 한 거의 모든 사항을 '코드 중심으로' 모아둔 집적체다.
  - How to Solve It / Polya
    문제 해결에 관한 한 최고의 베스트 셀러다. 국내에서 이 책의 가치가 제대로 평가되지 못하고 수학 시험 준비 서적으로 분류되고 있는 점이 아쉽다. 비단 수학뿐만 아니라 거의 모든 '문제 해결'이라고 할 만한 것에 대해 건강한 경험적 가이드라인을 제시하는 책으로 교육적 가치도 높다. 이 책을 공부하고('읽고'가 아니라) 나면 한층 똑똑해진 자신을 발견할 수 있다.
  - Godel, Escher, Bach: An Eternal Golden Braid / Hofstadter
    GEB라고도 불리는 이 책은, 저자 호프슈테더 교수에게 풀리처상을 안겨줬다. 수학의 괴델과, 회화의 에셔, 음악의 바흐 작품을 비교하며 공통점을 찾는다. 전산학의 시원이라 할 수 있는 튜링 컴퓨터에 대한 설명이 있다.
  - Computer Architecture: A Quant itative Approach / Patterson
    전문 프로그래머라면 하드웨어적인 지식도 절대 놓쳐서는 안 된다. 컴퓨터 아키텍처에 관한 한 최고의 양서로 평가받는 이 책은 학부생이나 평범한 프로그래머들이 보기엔 다소 난해할 수 있다.
  - Elements of Style / Strunk
    영미권에서 작문 관련 서적으로 가장 많이 팔린 책이다.
  - The Psychology of Computer Programming / Weinberg
    프로그래밍을 인간활동의 하나로 인식하고 심리학적인 접근을 통해 새로운 분야를 세운 기념비적인 책이다.
  - ACM Turing Award Lectures : The First Twenty Years : 1966 to 1985
    튜링상은 컴퓨터 분야의 노벨상이다. 이 책은 튜링상 수상시 함께 하도록 돼 있는 강의 내용을 20년간 모은 것이다. 한눈에 컴퓨터계의 발전 역사를 조망할 수 있으며, 선지자들이 조심스럽게 말하는 앞으로의 발전 방향도 엿볼 수 있다. 
- 위 책들은 이미 10년 이상을 살아 남앗고 앞으로도 최소 5년 이상 가치를 유지할(혹은 더 높아질) 책이 대부분이다.

<br>

#### 정기 간행물

- 과거를 보려면 서점에 나가보고, 현재를 보려면 정기 간행물이나 논문을 살펴보고, 미래를 보려면 현장(아카데미와 기업계)를 뛰어다녀 봐야 한다고 생각한다.
- 이미 서점에 판을 치고 있는 기술들은 그 정보 가치가 많이 하락한 것들이고 소위 '끝물'일 확률이 높다.
  - Software Development (sdmagazine.com)
    이 잡지는 특정 기술이나 팁보다는 전문 프로그래머가 접하는 일반적인 프로그래밍 관련 이슈를 다룬다.

<br>

#### 모임

- 컴퓨터 분야에는 '세계 수준의' 전문가 모임이 존재한다.
  - ACM (Association for Computing Machinery)
  - IEEE 컴퓨터 소사이어티

<br>

#### 효과적인 공부법

- 피드백이라는 것은 아주 중요한 역할을 한다. 내가 무엇을 잘못했는지, 제대로 했는지를 즉각적으로 알 수 있으면 바로 자신의 이전 행동에 대한 수정이 가능하고 이는 새로운 학습으로 이어질 수 있다.
- 처음부터 모든 완벽을 기하려는 사람보다 조금씩 시도해 보고 또 수정하고, 다시 시도하는 소위 점진적 접근법을 행하는 사람들이 더 빨리 학습하는 경우가 많이 있다.
- 규칙 중심적 학습은 경험 중심적 학습에 비해 훨씬 더 어렵고 비효율적일 수밖에 없다.
- 혼자 프로그래밍을 공부하는 사람이라면 자신의 프로그램이 제대로 돌지 않는 경우, 자신의 잘못을 분석하고 어떤 '사고의 틀'이 문제를 일으켰는지 생각해 봐야 한다. 한마디로 '자기 자신을 볼 줄 알아야 한다'는 것이다. 이것이 남보다 빨리 학습하는 비결이다.

