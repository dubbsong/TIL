## JavaScript The Good Parts

###### 자바스크립트 핵심 가이드 - Douglas Crockford

<br>

#### 역자 서문

- Ajax의 등장으로 JS의 중요성은 이전보다 훨씬 강조되고 있다.

<br>

#### 저자 서문

- 이 책은 JS 프로그래밍 언어에 관한 책이다.
- 이 책의 목적은 JS를 우연한 기회에 접하였거나 이에 대해 호기심이 생겨 탐험하고자 하는 프로그래머들을 위해 쓰여졌다.
- JS는 놀라울 정도로 강력한 언어이다.
- 이 책은 웹 개발자라면 반드시 숙지해야 될 JS에만 온전히 초점을 맞추고 있다.

------

<br>

### CHAPTER 01

### JS의 좋은 점들

- 대부분의 프로그래밍 언어에는 좋은 점(good parts)과 나쁜 점(bad parts)이 있다.
- 오랜 프로그래밍 경험으로 언어의 좋은 점만을 사용하고 나쁜 점은 사용을 자제함으로써 좀 더 좋은 프로그래머가 될 수 있다는 것을 알게 되었다. 결국, 요점은 어떻게 하면 나쁜 점을 피해서 좋은 결과를 얻느냐는 것이다.
- JS는 연구실에서 좀 더 좋게 정련하는 과정을 거치지 못한 체 세상으로 나왔지만 출현하자마자 단기간에 브라우저 전체에 채택되었다.
- 이 책에서는 JS의 진정한 본성을 드러내지 못하는 우아하지 않은 기능들을 모두 제거해 버렸다.

<br>

#### 01 | 왜 JS인가?

- JS는 웹 브라우저의 언어이기 때문에 세계에서 가장 유명하고 중요한 언어 중 하나이다. 하지만 그와 동시에 가장 무시 당하고 있는 언어 중에 하나이기도 하다.
- 브라우저의 API라고 할 수 있는 DOM(Document Object Model)은 아주 형편없는데, 거기에 편승하여 JS도 부당한 비난을 받고 있다.
- DOM은 어떠한 언어로 다루든지 용이하지 않다. DOM은 서툴게 정의됐으며 그에 따라 그 구현도 제 각각이다.
- JS의 놀라운 점은 언어 자체에 대해 많이 모르거나 심지어는 프로그래밍에 대해 잘 모르더라도 원하는 작업을 할 수 있다는 것이다.

<br>

#### 02 | JS 분석

- JS는 몇몇의 매우 좋은 아이디어와 몇몇의 나쁜 (그것도 아주) 아이디어에 기초하여 만들어졌다.
- 매우 좋은 아이디어에는 함수, 느슨한 타입 체크, 동적 객체, 표현적인 객체 리터럴 표기법 등이 있다.
- 대표할 만한 나쁜 아이디어는 프로그래밍 모델이 전역변수에 기초하고 있다는 것이다.
- JS의 함수는 어휘적 유효범위를 가진 일급 객체(first-class object)이다.
- JS는 C의 옷을 입은 Lisp라고 할 수 있다.
- 오늘날 프로그래밍 언어 대부분은 강력한 데이터 타입 체크를 요구한다. 이러한 경향은 타입 체크를 해야 컴파일러가 컴파일 시간에 가능한 많은 오류를 찾을 수 있다는 이론에 근거한 것이다.
- JS는 느슨한 타입 체크 언어이다. 그래서 JS 컴파일러는 타입 오류를 찾을 수 없다.
- 강력한 타입 체크가 중요한 오류들을 효율적으로 제거하지 못한다는 것이 판명되었다. 그리고 경험에 의하면 강력한 타입 체크가 오류를 알려주기는 하지만 실제로 우려하는 오류들은 알려주지 못한다. 반면에 느슨한 타입 체크에서 발견한 것은 오류 찾기의 어려움이 아니라 자유로움이다. 느슨한 타입 체크를 하는 언어를 사용하면 복잡한 클래스 계층을 구성할 필요도 없으며, 원하는 대로 동작하도록 타입 캐스팅과 씨름할 필요도 없다.
- JS는 매우 강력한 객체 리터럴 표기법이 있다. 이 표기법을 사용하면 단순히 필요한 요소들을 열거하는 방법으로 객체를 만들 수 있다. 이러한 표기법은 유명한 데이터 교환 형식인 JSON에도 영감을 주었다.
- JS에서 논란의 대상이 되는 기능은 프로토타입에 의한 상속이다.
- JS는 클래스가 필요 없는 객체 시스템이 있어서 특정 객체에 있는 속성들을 다른 객체에 직접 상속할 수 있다. 이러한 특성은 매우 강력하지만 클래스 기반의 언어에 익숙한 프로그래머에게는 친숙하지 않은 점이다.
- **JS에는 특별히 잘못 선택된 점이 하나 있는데,** 그것은 **전역변수에 근간을 두고 있다는 것**이다. 모든 컴파일 단위에 있는 최상위 레벨의 변수들은 모두 전역객체(global object)라 불리는 공용 이름 공간(namespace)에 위치하게 된다. 전역변수는 나쁘기 때문에 이러한 개념은 상당히 좋지 않다고 볼 수 있다. **그런데 이것이 JS의 근간을 이루는 것 중에 하나**이다. 그나마 다행인 것은 JS에는 이러한 문제를 완화시킬 수 있는 방법이 있다는 것이다.
- JS를 정의하고 있는 표준은 `The ECMAScript Programming Language third Edition`이다.
- JSLint라는 프로그래밍 툴은 JS 프로그램을 분석하여 포함된 나쁜 점들을 알려주는 JS 파서이다.
- JSLint는 보통 JS 개발에서 부족하기 쉬운 엄격한 수준의 분석 결과를 제공한다. 그러므로 이 툴의 분석에서 나쁜 점이 보고되지 않았다면 JS의 좋은 점만을 사용해서 프로그래밍됐다고 확신할 수 있다.
- **JS는 모순이 많은 언어**이다. '도대체 왜 JS를 사용해야 하지?'하고 생각할 수 있다. 이에 대한 답은 두 가지가 있다. 그 중 첫 번째는 **선택의 여지가 없다는 것**이다. 웹은 애플리케이션 개발에 있어 중요한 플랫폼이며, JS는 모든 브라우저에서 사용할 수 있는 유일한 언어이다. 두 번째 답은 **많은 부족한 면이 있기는 하지만 JS는 실제로 꽤 괜찮다는 것**이다. JS는 매우 경량화돼 있으며 표현적(expressive)이다. 그리고 일단 언어 사용의 요령을 익히고 나면 함수형 프로그래밍(functional programming)이 꽤 재미있다는 것을 알게 된다.
- JS라는 언어를 잘 사용하기 위해서는 이 언어의 한계점을 잘 알아야 한다.

<br>

#### 03 | 예제 테스트를 위한 간단한 준비

- 웹 브라우저와 텍스트 에디터만 있으면 JS 프로그램을 실행시킬 모든 준비가 끝난 것이다.

- ```html
  // program.html

  <html>
      <body>
          <pre>
          	<script src="program.js">
          	</script>
          </pre>
      </body>
  </html>
  ```

- ```javascript
  // program.js

  document.writeln('Hello, world!');
  ```

- ```javascript
  // 새로운 메소드를 정의할 때 쓰이는 method라는 메소드

  Function.prototype.method = function(name, func) {
      this.prototype[name] = func;
      return this;
  };
  ```

<br>

### CHAPTER 02

### JS의 좋은 문법들

<br>

#### 01 | 공백 (whitespace)

- 주석 역시 공백이다.
- 주석은 프로그램의 가독성을 높이기 위해 충분히 사용되는 것이 좋다.
- 쓸모 없는 주석은 없느니만 못하다.
- JS에서 블록 주석 방법은 안전하지 않다. 정규 표현식 리터럴과의 조합이 구문 오류를 발생한다.

<br>

#### 02 | 이름 (Names)

- 문장, 변수, 매개변수, 속성명, 연산자, 라벨 등에 사용한다.
- 예약어들은 이름이 될 수 없다.

<br>

#### 03 | 숫자 (Numbers)

- 내부적으로 숫자는 64비트 부동 소수점 형식을 지닌다. 이는 자바의 double 형과 같다.
- JS에는 정수와 실수의 구분이 없다. 즉 1과 1.0은 같은 값이다.
- 결국 숫자형 때문에 발생하는 오류 대부분을 피할 수 있다.
- NaN은 수치 연산을 해서 정상적인 값을 얻지 못할 때의 값이다.
- NaN은 그 자신을 포함해서 어떤 값하고도 같지 않다.
- NaN인지 확인하려면 비교 구문이 아니라 isNaN()이라는 함수를 사용한다.

<br>

#### 04 | 문자열 (Strings)

- 문자열은 작은 따옴표나 큰 따옴표로 묶어서 나타내며, 따옴표 안에는 문자 0개 이상을 포함한다.
- JS 내의 모든 문자는 16비트 유니코드이다
- JS에는 문자 타입이 없다.
- \\(백슬래시)는 이스케이프 문자이다.
- 문자열은 length라는 속성이 있다.
- 문자열은 변하지 않는다(immutable).

<br>

#### 05 | 문장 (Statements)

- 하나의 컴파일 단위에는 실행을 위한 문장들이 포함돼 있다.
- 블록은 중괄호로 쌓인 문장들의 집합이다.
- 다른 언어들과 달리 JS에서 블록은 새로운 유효범위(scope)를 생성하지 않는다. 이러한 이유로 변수는 블록 안에서가 아니라 함수의 첫 부분에서 정의해야 한다.


- var 문은 함수 내부에서 사용될 때 함수의 private 변수를 정의한다.
- if 문은 표현식의 값에 따라 프로그램의 흐름을 변경한다.
  - 거짓에 해당하는 값: false, null, undefined, '', 0, NaN
- switch 문은 다중 분기를 수행한다. 일치하는 표현식을 찾으면 해당 case 절에 있는 문장들을 실행하고, 일치하는 표현식을 찾지 못하는 경우에는 Default 절의 문장들을 실행한다.
- case 절은 하나 이상의 case 문을 포함한다. case 절의 문장 마지막에는 다음 case 절로 넘어가지 않게 실행 흐름을 벗어나는 문장인 break 문을 사용할 수 있다.
- while 문은 단순한 반복 수행 문장이다. 표현식이 참인 동안은 블록을 반복해서 실행하며, 표현식이 거짓이면 반복 수행은 끝난다.
- for 문은 두 가지 형식으로 사용한다.
  - 일반적인 형식은 초기화, 조건, 증가라는 세 가지 절로 제어하는 구조이다. 조건 부분이 생략되면 참으로 간주하고, 조건 부분의 검사가 거짓이면 반복을 종료한다. 조건을 만족해서 블록을 한 번 실행하면 증가 부분을 실행하고 다시 조건 검사를 반복한다.
  - 다른 형식은 객체의 속성 이름(또는 키)을 열거하는 것이다. 이러한 형식을 for in이라고 한다. 각각의 반복 실행마다 객체에 있는 각각의 속성 이름을 변수에 할당한다. for in 형식은 보통 object.hasOwnProperty(변수) 메소드로 속성 이름이 실제로 객체의 속성인지 아니면 프로토타입(prototype chain) 상에 있는 것인지를 확인하는 것이 필요하다.
- do 문은 표현식이 블록이 실행하기 전이 아니라 실행한 후에 검사된다는 점만 빼면 while 문과 같다. 이러한 특성 때문에 적어도 한 번 블록을 실행한다.
- try 문은 블록을 실행하면서 블록 내에서 발생하는 예외 상황을 포착한다.
- catch 절은 예외 객체를 받는 새로운 변수를 정의한다.
- throw 문은 예외를 발생한다. 만약 throw 문이 try 블록 안에 있으면 실행의 제어는 catch 절로 이동한다. 만약 throw 문이 일반적인 함수 내에 있다면 함수 호출은 중단되고 함수를 호출한 try 문의 catch 절로 실행 흐름이 이동한다.
- return 문은 함수에서 호출한 곳으로 되돌아가는 역할을 한다. 또한 반환값을 지정한다. 표현식이 지정되지 않으면 undefined를 반환한다.
- break 문은 반복문이나 switch 문에서 흐름을 벗어나게 하는 역할을 한다. 이 문장은 라벨 이름을 취할 수 있는데, 라벨이 주어지면 라벨이 붙은 문장의 끝으로 이동한다.
- = 연산자는 할당하는 데 사용한다.

<br>

#### 06 | 표현식 (Expressions)

- 표현식은 리터럴 값(문자열이나 숫자), 변수, 내장값들(true, false, null, undefined, NaN, Infinity 등), new 키워드에 의한 호출 표현식, delete 키워드 다음에 나오는 세부지정 표현식, 괄호로 쌓인 표현식, 전치 연산자 다음에 이어지는 표현식 등이다.
- ? 삼항 연산자는 3개의 피연산자를 취한다. 첫 번째 피연산자가 참이면, 두 번째 피연산자가 값이 된다.
- typeof 연산자의 결과값에는 number, string, boolean, undefined function, object 등이 있다.
- 피연산자가 배열이나 null이면 결과는 모두 object인데 이는 약간 문제가 있다. (뒤에서 자세히)
- ! 연산자의 피연산자 값이 참이면 결과값은 거짓이며, 그 반대면 결과값은 참이다.
- \+ 연산자는 수를 더하거나 문자열을 연결한다. 더하기 연산을 원하는 경우에는 반드시 피연산자 두 개가 모두 숫자여야 한다.
- && 연산자는 첫 번째 피연산자가 거짓일 경우 첫 번째 피연산자의 값을 취하고, 그렇지 않은 경우에는 두 번째 피연산자 값을 결과값으로 취한다.
- || 연산자는 &&와 반대로 취한다.
- 호출은 함수를 실행한다. 호출 연산자는 함수 이름 뒤에 이어지는 한 쌍의 괄호이다. 괄호 내에는 함수에 전달하는 인수를 포함할 수 있다.
- 세부지정은 객체의 속성이나 배열의 구성요소를 지정할 때 사용한다.

<br>

#### 07 | 리터럴 (Literals)

- 객체 리터럴은 새로운 객체를 생성할 때 편리한 표기법이다.
- 배열 리터럴은 새로운 배열을 생성할 때 편리한 표기법이다.
- 정규 표현식(뒤에서 자세히).

<br>

#### 08 | 함수 (Function)

- 함수 리터럴은 함수값을 정의한다.
- 함수 리터럴은 이름을 가질 수 있는데, 이 이름은 자신을 재귀적으로 호출할 때 사용할 수 있다.
- 함수 리터럴은 매개변수 목록을 가질 수 있는데, 이 매개변수는 함수 호출 시 넘어온 인수로 초기화되는 변수이다.

<br>

### CHAPTER 03

### 객체

- JS에서 단순한 **데이터 타입**은 **숫자, 문자열, 불리언, null, undefined**가 있다. **이들을 제외한 다른 값들은 모두 객체이다.**
- 숫자, 문자열, 불리언은 메소드가 있기 때문에 **유사 객체**라고 할 수 있다. 하지만 이들은 값이 정해지면 변경할 수 없다(immutable).
- **JS의 객체**는 **변형 가능한 속성들의 집합**이라고 할 수 있다.
- **객체**는 **이름과 값이 있는 속성들을 포함하는 컨테이너**다.
- 속성의 이름은 문자열이면 모두 가능하다. 여기에는 빈 문자열도 포함한다.
- 속성의 값은 undefined를 제외한 JS의 모든 값이 사용될 수 있다.
- JS의 객체는 클래스가 필요 없다(class-free).
- 객체는 데이터를 한 곳에 모으고 구조화하는데 유용하다.
- 객체 하나는 다른 객체를 포함할 수 있기 때문에, 그래프나 트리 같은 자료구조를 쉽게 표현할 수 있다.
- JS에는 **객체 하나에 있는 속성들을 다른 객체에 상속하게 해주는 프로토타입(prototype) 연결 특성**이 있다. 이 특성을 잘 활용하면, 객체를 초기화하는 시간과 메모리 사용을 줄일 수 있다.

<br>

#### 01 | 객체 리터럴

- 객체 리터럴은 새로운 객체를 생성할 때 매우 편리한 표기법을 제공한다.
- 속성(property)의 이름은 어떤 문자열이라도 가능하다. 여기에는 빈 문자열도 포함한다.
- 쉼표(,)는 `속성 이름: 값` 쌍들을 구분하는데 사용한다.
- 중첩된 객체도 가능하다.

<br>

#### 02 | 속성값 읽기

- 객체에 속한 속성의 값은 속성 이름을 대괄호 []로 둘러싼 형태로 읽을 수 있다.
- 속성 이름이 유효한 JS 이름이고, 예약어가 아닐 경우에는, 마침표(.) 표기법을 대신 사용할 수 있다.
- 객체에 존재하지 않는 속성을 읽으려고 하면 undefined를 반환한다.
- 존재하지 않는 속성, 즉 undefined의 속성을 참조하려 할 때 `TypeError 예외`가 발생한다. 이런 상황을 방지하기 위해서 && 연산자를 사용할 수 있다.

<br>

#### 03 | 속성값의 갱신

- 객체의 값은 할당에 의해 갱신한다.
- 할당하는 표현식에서 속성 이름이 이미 객체 안에 존재하면 해당 속성의 값만 교체한다.
- 속성이 객체 내에 존재하지 않는 경우에는 해당 속성을 객체에 추가한다.

<br>

#### 04 | 참조

- 객체는 참조 방식으로 전달된다. 결코 복사되지 않는다.

- ```javascript
  var x = stooge;
  x.nickname = 'Curly';
  var nick = stooge.nickname;
  	// x와 stooge가 모두 같은 객체를 참조하기 때문에,
  	// 변수 nick의 값은 'Curly'

  var a = {}, b = {}, c = {};
  	// a, b, c는 각각 다른 빈 객체를 참조
  a = b = c = {};
  	// a, b, c는 모두 같은 빈 객체를 참조
  ```

<br>

#### 05 | 프로토타입 (Prototype)

- 모든 객체는 속성을 상속하는 프로토타입 객체에 연결되어 있다.

- 객체 리터럴로 생성되는 모든 객체는 JS의 표준 객체인 Object의 속성인 prototype(Object.prototype) 객체에 연결된다.

- 객체를 생성할 때는 해당 객체의 프로토타입이 될 객체를 선택할 수 있다.

- create는 넘겨받은 객체를 프로토타입으로 하는 새로운 객체를 생성하는 메소드이다.

- ```javascript
  if (typeof Object.create !== 'function') {
      Object.create = function(o) {
          var F = function() {};
          F.prototype = o;
          return new F();
      };
  }
  var another_stooge = Object.create(stooge);
  ```

- 프로토타입 연결은 값의 갱신에 영향을 받지 않는다. 즉 객체를 변경하더라도 객체의 프로토타입에는 영향을 미치지 않는다.

- 프로토타입 연결은 오로지 객체의 속성을 읽을 때만 사용한다.

- 프로토타입 관계는 동적 관계이다.

<br>

#### 06 | 리플렉션 (reflection)

- typeof 연산자는 속성의 타입을 살펴보는데 매우 유용하다.

- ```javascript
  typeof flight.number	// 'number'
  typeof flight.status	// 'string'
  typeof flight.arrival	// 'object'
  typeof flight.manifest	// 'undefined'
  ```

- 때때로 해당 객체의 속성이 아니라 프로토타입 체인 상에 있는 속성을 반환할 수 있기 때문에 주의할 필요가 있다.

- 객체에 특정 속성이 있는지를 확인하여 true/false 값을 반환하는 hasOwnProperty 메소드는 프로토타입 체인을 바라보지 않는다.

<br>

#### 07 | 열거 (Enumeration)

- for in 구문을 사용하면 객체에 있는 모든 속성의 이름을 열거할 수 있다. 이러한 열거 방법에는 함수나 프로토타입에 있는 속성 등 모든 속성이 포함되기 때문에 원하지 않는 것들을 걸러낼 필요가 있다. 가장 일반적인 필터링 방법은 hasOwnProperty 메소드와 함수를 배제하기 위한 typeof를 사용하는 것이다.

- ```javascript
  var name;
  for (name in another_stooge) {
      if (typeof another_stooge[name] !== 'function') {
          document.writeln(name + ': ' + another_stooge[name]);
      }
  }
  ```

- for in 구문을 사용하면 속성들이 이름순으로 나온다는 보장이 없다. 그러므로 특정 순으로 속성 이름들이 열거되기를 원한다면 for in 구문을 사용하지 말고, 속성이 열거되기 원하는 순서를 특정 배열로 지정하고 이 배열을 이용하여 객체의 속성을 열거할 수 있다.

<br>

#### 08 | 삭제

- delete 연산자를 사용하면 객체의 속성을 삭제할 수 있다.
- delete 연산자는 해당 속성이 객체에 있을 경우에 삭제를 하며, 프로토타입 연결 상에 있는 객체들은 접근하지 않는다.

<br>

#### 09 | 최소한의 전역변수 사용

- JS에서는 전역변수 사용이 매우 쉽다. 불행히도 전역변수는 프로그램의 유연성을 약화하기 때문에 가능하면 피하는 것이 좋다.
- 정보은닉을 위해 사용하는 클로저(closure)는 전역변수 사용을 줄이는 효과적인 방법 중 하나이다.

<br>

### CHAPTER 04

### 함수

- JS에서 함수는 거의 대부분 제대로 된 특성들로 이루어져 있다.
- 함수는 실행 문장들의 집합을 감싸고 있다.
- 함수는 JS에서 모듈화의 근간이다.
- 함수는 코드의 재사용이나 정보의 구성 및 은닉 등에 사용하고, 객체의 행위를 지정하는데도 사용한다.
- 일반적으로 프로그래밍 기술은 요구사항의 집합을 함수와 자료구조의 집합으로 변환하는 것이다.

<br>

#### 01 | 함수 객체

- JS에서 함수는 객체이다. 객체는 프로토타입 객체로 숨겨진 연결을 갖는 이름/값 쌍들의 집합체이다.
- 객체 리터럴로 생성되는 객체는 Object.prototype에 연결된다. 반면에 함수 객체는 Function.prototype에 연결된다(Function은 Object.prototype에 연결된다).
- 모든 함수는 숨겨져 있는 두 개의 추가적인 속성이 있는데, 이 속성들은 함수의 문맥(context)과 함수의 행위를 구현하는 코드(code)이다.
- 모든 함수 객체는 prototype이라는 속성이 있다. 이 속성의 값은 함수 자체를 값으로 갖는 constructor라는 속성이 있는 객체이다. 이는 Function.prototype으로 숨겨진 연결과는 구분된다.
- 함수는 객체이기 때문에, 변수나 객체, 배열 등에 저장되며, 다른 함수에 전달하는 인수로도 사용하고, 함수의 반환값으로도 사용한다.
- 함수를 다른 객체와 구분 짓는 특징은 호출할 수 있다는 것이다.

<br>

#### 02 | 함수 리터럴

- 함수 객체는 함수 리터럴로 생성할 수 있다.

- ```javascript
  // add라는 변수를 생성하고 두 수를 더하는 함수를 이 변수에 저장

  var add = function(a, b) {
      return a + b;
  };
  ```

- 함수 리터럴의 네 가지 부분

  1. function이라는 예약어
  2. 선택사항으로 함수의 이름
     함수의 이름은 함수를 재귀적으로 호출할 때 사용한다.
     함수의 이름이 주어지지 않은 경우 익명함수(anonymous)라고 부른다.
  3. 괄호로 둘러싸인 함수의 매개변수 집합
     괄호 안에 아예 없거나, 하나 이상의 매개변수를 쉼표로 분리해서 열거한다.
     이 매개변수들은 함수 내에서 변수로 정의한다.
     일반적인 변수들을 undefined로 초기하는 것과는 달리,
     매개변수는 함수를 호출할 때 넘겨진 인수로 초기화한다.
  4. 중괄호로 둘러싸인 문장들의 집합
     문장들은 함수의 몸체(body)이며, 함수를 호출했을 때 실행한다.

- 함수는 다른 함수 내에서도 정의할 수 있다.

- 함수 리터럴로 생성한 함수 객체는 외부 문맥으로의 연결이 있는데, 이를 클로저(closure)라고 한다.

<br>

#### 03 | 호출

- 함수를 호출하면 현재 함수의 실행을 잠시 중단하고 제어를 매개변수와 함께 호출한 함수로 넘긴다.
- 모든 함수는 명시되어 있는 매개변수에 더해서 this와 arguments라는 추가적인 매개변수 두 개를 받게 된다.
- this라는 매개변수는 개체지향 프로그래밍 관점에서 매우 중요하며, 이 매개변수의 값은 호출하는 패턴에 의해 결정된다.
- JS에는 함수를 호출하는데 **메소드 호출 패턴, 함수 호출 패턴, 생성사 호출 패턴, apply 호출 패턴**이라는 네 가지 패턴이 있다. 각각의 패턴에 따라 this라는 추가적인 매개변수를 다르게 초기화한다.
- 함수를 호출하는 호출 연산자는 함수를 나타내는 표현식 뒤에 이어지는 한 쌍의 괄호이다.

<br>

###### 메소드 호출 패턴

- ​
































<br>

> 언어상에 제약이 없는 객체를 일급 객체라고 한다.
>
> 즉 변수에 대입되거나 인수로 넘길 수도 있고,
>
> 반환값으로 사용하거나 연산 등에 사용하는데 전혀 제약이 없는 객체이다.
>
> JS에서는 함수가 일급 객체이므로 이 모든 것이 다 가능하다.

<br>